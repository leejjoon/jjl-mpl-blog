[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/mpl-20240318-mpl-flags/index.html",
    "href": "posts/mpl-20240318-mpl-flags/index.html",
    "title": "mpl-flags : drawing flags with Matplotlib",
    "section": "",
    "text": "mpl-flags : drawing flags with Matplotlib\nThis post is to introduce mpl-flags package. To demonstrate the package, we would like to reproduce the plot from this post, only the barchart part.\nHere is what the output will look like.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.offsetbox import (TextArea, DrawingArea, AnnotationBbox, VPacker)\nfrom matplotlib.patches import Circle\nfrom mpl_flags import Flags\n\nimport pandas as pd\nimport io\n\ncsvs = \"\"\"Country,2024 Real GDP % Change,Code\nIndia,6.5,IN\nIndonesia,5,ID\nChina,4.6,CN\nTürkiye,3,TR\nArgentina,2.8,AR\nMexico,2.7,MX\nSaudi Arabia,2.7,SA\nRussia,2.6,RU\nKorea,2.2,KR\nU.S.,2.1,US\nBrazil,1.7,BR\nCanada,1.4,CA\nAustralia,1.2,AU\nFrance,1,FR\nSouth Africa,1,ZA\nJapan,0.9,JP\nItaly,0.7,IT\nUnited Kingdom,0.6,GB\nGermany,0.5,DE\n\"\"\"\n\ndf = pd.read_csv(io.StringIO(csvs))\nfig, ax = plt.subplots(1, 1, num=1, figsize=(7, 10), clear=True,\n                       facecolor=\"gold\")\ncountries = df[\"Country\"]\ngdp_changes = df[\"2024 Real GDP % Change\"]\ncountry_codes = df[\"Code\"]\n\npalette = sns.color_palette(\"crest\", n_colors=len(countries))\npalette.reverse()\n\nsns.barplot(x=gdp_changes, y=countries,\n            hue=countries,\n            palette=palette,\n            width=0.9,\n            ax=ax)\n\n\nfor country, gdp_change, bar in zip(countries, gdp_changes, ax.patches):\n    t1 = TextArea(country, textprops=dict(size=10))\n    t2 = TextArea(f\"{gdp_change}%\", textprops=dict(size=14))\n    tt = VPacker(align=\"left\", children=[t1, t2], sep=2)\n    ab = AnnotationBbox(tt, (1, 0.5), xybox=(5, 0),\n                        frameon=False,\n                        xycoords=bar,\n                        boxcoords=\"offset points\",\n                        box_alignment=(0., 0.5))\n    ax.add_artist(ab)\n\nflags = Flags(\"circle\")\n\nkw = dict(frameon=False,\n          box_alignment=(0.5, 0.5))\n\nfor country, code, bar in zip(countries, country_codes, ax.patches):\n\n    # draw white circular background around the flags\n    da = DrawingArea(20, 20, clip=False)\n    da.add_artist(Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\n    da = flags.get_drawing_area(code, wmax=25)\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\nfrom matplotlib.patches import FancyArrowPatch\n\n\nda = DrawingArea(70, 10, clip=False)\narrow = FancyArrowPatch(posA=(0, 5), posB=(70, 5),\n                        arrowstyle='fancy,tail_width=0.2', connectionstyle='arc3',\n                        mutation_scale=15, ec=\"none\", fc=\"w\")\nda.add_artist(arrow) # Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\nt1 = TextArea(\"2024 Real GDP % Change\", textprops=dict(size=12, color=\"w\"))\ntt = VPacker(align=\"right\", children=[t1, da], sep=2)\n\nab = AnnotationBbox(tt, (0.98, 0.5), xycoords=ax.patches[0],\n                    frameon=False,\n                    box_alignment=(1, 0.5))\nax.add_artist(ab)\n\nfig.subplots_adjust(top=0.95, bottom=0.05)\nfig.set_facecolor(\"gold\")\nax.set_axis_off()\n\nplt.show()\n\n\n\n\n\n\n\nmpl-flags\nmpl-flags is a small packages to draw flags in your matplotlib plots It contains the flag data in vector format readily usable with Matplotlib. The original flags data are from svg format, converted to matplotlib’s Path data using mpl-simple-svg-parser. mpl-flags does not contain the original svg files, only the converted data in numpy format (vertices and codes).\n\nfrom mpl_flags import Flags\n\nflags = Flags(\"noto_waved\") # You initialize the Flags class specifying what kind of flags you like to use.\n                            # `noto_waved` is flags from google's noto emoji fonts.\n\nfig, ax = plt.subplots(figsize=(3, 3))\n\nflags.show_flag(ax, \"KR\")\n\n\n\n\nshow_flag method draws the flag in data coordinate.\nThe flag data is collected from various sources. Currently, it includes flags from\n\nGoogle’s noto color emoji font : https://github.com/googlefonts/noto-emoji\ncircle-flags : https://github.com/HatScripts/circle-flags\nflag-icons : https://github.com/lipis/flag-icons\n\nDifferent sources can render the flags differently. You may compare flags of different sources.\n\nfig = plt.figure(figsize=(8, 4), constrained_layout=False)\nsspec = fig.add_gridspec(1, 1)[0, 0]\ncountry_code = \"KR\"\nFlags.show_flag_kinds(sspec, country_code)\n\n\n\n\nSo, there are 6 flag kinds from 3 sources.\nThe country code is based on 2 letter code.\n\nFlags.print_flags_summary()\n\n[All Codes]\nAC AD AE AF AG AI AL AM AN AO AQ AR AS AT AU AW AX AZ BA BB BD BE BF BG BH\nBI BJ BL BM BN BO BQ BR BS BT BV BW BY BZ CA CC CD CF CG CH CI CK CL CM CN\nCO CP CQ CR CU CV CW CX CY CZ DE DG DJ DK DM DO DZ EA EC EE EG EH ER ES ET\nEU FI FJ FK FM FO FR FX GA GB GD GE GF GG GH GI GL GM GN GP GQ GR GS GT GU\nGW GY HK HM HN HR HT HU IC ID IE IL IM IN IO IQ IR IS IT JE JM JO JP KE KG\nKH KI KM KN KP KR KW KY KZ LA LB LC LI LK LR LS LT LU LV LY MA MC MD ME MF\nMG MH MK ML MM MN MO MP MQ MR MS MT MU MV MW MX MY MZ NA NC NE NF NG NI NL\nNO NP NR NU NZ OM PA PC PE PF PG PH PK PL PM PN PR PS PT PW PY QA RE RO RS\nRU RW SA SB SC SD SE SG SH SI SJ SK SL SM SN SO SR SS ST SU SV SX SY SZ TA\nTC TD TF TG TH TJ TK TL TM TN TO TR TT TV TW TZ UA UG UK UM UN US UY UZ VA\nVC VE VG VI VN VU WF WS XK XX YE YT YU ZA ZM ZW\n\n[Missing Codes]\nnoto_original:  CQ AN PC SU XX UK YU FX\nnoto_waved:  CQ AN PC SU XX UK YU FX\n1x1:  CQ AN AC SU UK YU FX EA TA\n4x3:  CQ AN AC SU UK YU FX EA TA\ncircle:  PC\nsimple:  PC\n\n\nAbove example of Korean flag is relatively simple and are modstly identical among kinds. However, for a bit complicated flags, different kinds show different flags. “circle” and “simple” show simplified flags without much details, best for small size, while other kinds reproduce the original flags.\n\nfig = plt.figure(figsize=(8, 4), constrained_layout=False)\nsspec = fig.add_gridspec(2, 1)[0, 0]\ncountry_code = \"US\"\nFlags.show_flag_kinds(sspec, country_code)\n\nsspec = fig.add_gridspec(2, 1)[1, 0]\ncountry_code = \"VG\"\nFlags.show_flag_kinds(sspec, country_code)\n\n\n\n\nmpl-flags package itself does not provide a mechanism to search for the country from common country name. For that, you may use packages like pycountry.\nIn the above example, we used show_flag method to draw the flag in data coordinate. Often, this is not you want. You want it to behave like texts.\nThus you are recommended to use get_drawing_area method. This returns matplotlib.offsetbox’s DrawingArea instance.\nIf you are not familar with these, you may take a look at this guide\n\nfrom matplotlib.offsetbox import AnnotationBbox\n\nflags = Flags(\"noto_original\")\n\nfig, ax = plt.subplots(figsize=(3, 3))\nda = flags.get_drawing_area(\"KR\", wmax=100)\nab = AnnotationBbox(da, (0.5, 0.5), frameon=True,\n                    box_alignment=(0.5, 0.5))\nax.add_artist(ab)\n\n&lt;matplotlib.offsetbox.AnnotationBbox at 0x7fd5069febf0&gt;\n\n\n\n\n\nNow, let’s see how we can creat the barplots with flags. We will start the demo by loading the data as pandas DataFrame.\n\nimport pandas as pd\nimport io\n\ncsvs = \"\"\"Country,2024 Real GDP % Change,Code\nIndia,6.5,IN\nIndonesia,5,ID\nChina,4.6,CN\nTürkiye,3,TR\nArgentina,2.8,AR\nMexico,2.7,MX\nSaudi Arabia,2.7,SA\nRussia,2.6,RU\nKorea,2.2,KR\nU.S.,2.1,US\nBrazil,1.7,BR\nCanada,1.4,CA\nAustralia,1.2,AU\nFrance,1,FR\nSouth Africa,1,ZA\nJapan,0.9,JP\nItaly,0.7,IT\nUnited Kingdom,0.6,GB\nGermany,0.5,DE\n\"\"\"\n\ndf = pd.read_csv(io.StringIO(csvs))\n\nThen, we will create a bar chart plot, without flags. Note that we are adding texts using AnnotationBbox and providing the bar itself as a coordinate, which means we will use a coordinate that is normalized to the extent of the bar.\n\n# Set up the matplotlib figure\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.offsetbox import (TextArea, DrawingArea, AnnotationBbox, VPacker)\nfrom matplotlib.patches import FancyArrowPatch\n\n\nfig, ax = plt.subplots(1, 1, num=1, figsize=(7, 10), clear=True,\n                       facecolor=\"gold\")\ncountries = df[\"Country\"]\ngdp_changes = df[\"2024 Real GDP % Change\"]\ncountry_codes = df[\"Code\"]\n\npalette = sns.color_palette(\"crest\", n_colors=len(countries))\npalette.reverse()\n\nsns.barplot(x=gdp_changes, y=countries,\n            hue=countries,\n            palette=palette,\n            width=0.9,\n            ax=ax)\n\n# Add text labels of country name and percentage\nfor country, gdp_change, bar in zip(countries, gdp_changes, ax.patches):\n    t1 = TextArea(country, textprops=dict(size=10))\n    t2 = TextArea(f\"{gdp_change}%\", textprops=dict(size=14))\n    tt = VPacker(align=\"left\", children=[t1, t2], sep=2)\n    ab = AnnotationBbox(tt, (1, 0.5), xybox=(5, 0),\n                        frameon=False,\n                        xycoords=bar,\n                        boxcoords=\"offset points\",\n                        box_alignment=(0., 0.5))\n    ax.add_artist(ab)\n\n# For the top bar, we add text explaing the current plot.\nda = DrawingArea(70, 10, clip=False)\narrow = FancyArrowPatch(posA=(0, 5), posB=(70, 5),\n                        arrowstyle='fancy,tail_width=0.2', connectionstyle='arc3',\n                        mutation_scale=15, ec=\"none\", fc=\"w\")\nda.add_artist(arrow) # Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\nt1 = TextArea(\"2024 Real GDP % Change\", textprops=dict(size=12, color=\"w\"))\ntt = VPacker(align=\"right\", children=[t1, da], sep=2)\n\nab = AnnotationBbox(tt, (0.98, 0.5), xycoords=ax.patches[0],\n                    frameon=False,\n                    box_alignment=(1, 0.5))\nax.add_artist(ab)\n\n# adjust subplot parameters and set the backgrond to gold.\nfig.subplots_adjust(top=0.95, bottom=0.05)\nfig.set_facecolor(\"gold\")\nax.set_axis_off()\n\n\n\n\nWe are now going to add flags. If you know how annoatation_box works, adding flags is very straight forward. In the example below, we will create two DrawingArea per bar. The first one is to draw a white background circle for the flags. And another DrawingArea for flags of circle kind.\n\n\nfrom matplotlib.patches import Circle\nfrom mpl_flags import Flags\nflags = Flags(\"circle\")\n\nkw = dict(frameon=False,\n          box_alignment=(0.5, 0.5))\n\nfor country, code, bar in zip(countries, country_codes, ax.patches):\n\n    # draw white circular background around the flags\n    da = DrawingArea(20, 20, clip=False) # since we are using box_aligment=(0.5, 0.5) and clip=Flase,\n                                        # the size of Drawing Area does not realy matter\n    da.add_artist(Circle((10, 10), 15, ec=\"none\", fc=\"w\")) # place the circle at the center of the drawing_area.\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\n    # Now we draw flags.\n    da = flags.get_drawing_area(code, wmax=25)\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\n\n\n\n\n\n\n\nno gradient support\nSome flags (the original svg files) use gradient, which is not currently supported by mpl-flags. Below, we compare original svg file (left) and mpl-flags flag rendering. You will notice what mpl-flags result misses some colors.\n\n# list of flags with gradient\n\nwith_gradients = {\n    \"noto_original\": ['BZ', 'EC', 'FK', 'GS', 'GT', 'MX', 'NI', 'PM', 'TA', 'VG'],\n    \"4x3\": ['BZ', 'FK', 'GS', 'GT', 'MX', 'NI', 'VG']\n}\n\n\nflags = Flags(\"noto_original\")\ncodes = with_gradients[\"noto_original\"]\nget_filename = lambda code: f\"../../../../mpl-flags/third_party/noto-emoji/third_party/region-flags/svg/{code}.svg\"\n\nfig = plt.figure(num=1, figsize=(4, 8))\ncompare_svg(fig, flags, codes, get_filename)\n\n\n\n\n\nflags = Flags(\"4x3\")\ncodes = with_gradients[\"4x3\"]\nget_filename = lambda code: f\"../../../../mpl-flags/third_party/flag-icons/flags/4x3/{code.lower()}.svg\"\n\nfig = plt.figure(num=1, figsize=(4, 6.5))\ncompare_svg(fig, flags, codes, get_filename)"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "PatternMonster provide a greate collection of patterns in svg format. mpl-pe-pattern-monster is a package that lets you use these patterns in matplotlib. The original svg files are converted to matplotlib path definitions and included as a numpy array.\nThis tutorial will provide a simple example of barchart with christmas-related patterns.\nWe start from a simple barchart Adopted from https://matplotlib.org/stable/gallery/lines_bars_and_markers/barchart.html\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nspecies = (\"Adelie\", \"Chinstrap\", \"Gentoo\")\npenguin_means = {\n    'Bill Depth': (18.35, 18.43, 14.98),\n    'Bill Length': (38.79, 48.83, 47.50),\n}\n\nx = np.arange(len(species))  # the label locations\ntotal_width = 0.7  # total width of the group\ndw = 0.2 # fraction of space between bars in the same group\nwidth = total_width / (len(penguin_means) + dw * (len(penguin_means) - 1))\n\nfig, ax = plt.subplots(num=1, clear=True, figsize=(8, 6))\n\nfor i, (attribute, measurement) in enumerate(penguin_means.items()):\n    offset = width * (1 + dw) * i\n    rects = ax.bar(x - 0.5 * total_width + offset, measurement, width,\n                   label=attribute, align=\"edge\")\n    ax.bar_label(rects, padding=3)\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel('Length (mm)')\nax.set_title('Penguin attributes by species')\nax.set_xticks(x, species)\nax.set_ylim(0, 58)\n\n''\n\n\n\n\n\n\n\n\n# First, you need to know the names of the patterns you are going to use.\n# The python package itself does not provide a good way to browse the patterns.\n# You can list the names of patterns by\npm.names[:10]  # We only show the first 10 items.\n\n['waves-1',\n 'waves-2',\n 'waves-3',\n 'waves-4',\n 'waves-5',\n 'waves-6',\n 'waves-7',\n 'chevron-1',\n 'chevron-2',\n 'chevron-3']\n\n\n\n# names are categorized by roots and tags\npm.roots # outputs are suppressed\npm.tags  # outputs are suppressed\n\n\n\n\n\n\n\n\nThe python package only contains path definition, not colors. And you need to provide suitable colors for your pattern.\nIf color_cycle is not specified, the default color cycle of [“C0”, “C1”, …] will be used.\nIf the given color_cycle contains None, it will be interpreted as the facecolor of the parent artist.\nNote that patterns of pattern_monster are rendered using the custom patheffects. If you are not familiar with patheffect, take a look at patheffects-guide\nThe code below uses mpl-visual-context, but I won’t go into details for its use for now.\n\n\n# pattern names, colors and scale factor. Note that all the pattern names in the python package is in lower-case.\n# The colors also from pattern.monster's pallette, that I think go well with the christmas.\n\npatterns = [(\"christmas-tree-1\",\n             [\"#009688\", \"#E91E63\", \"#03A9F4\", \"#ECC94B\"],\n             1),\n            (\"christmas-pattern-2\",\n             [\"#F6AD55\", \"#E91E63\", \"#03A9F4\"],\n             1.5)]\n\nfor bars, slug_colors_scale in zip(ax.containers, patterns):\n\n    slug, colors, scale = slug_colors_scale\n    pattern = pm.get(slug, scale=scale)  # we get the pattern instance using its name, a scale factor.\n    pattern_fill = pattern.fill(ax, color_cycle=colors, alpha=0.5)\n    # its 'fill' method with return patheffect instance.\n\n    path_effects = [\n        pe.FillColor(colors[0]) | pe.GCModify(alpha=0.3),  # Change the fill color and set alpha to 0.3\n        pe.StrokeColor(colors[0]) | pe.GCModify(linewidth=2, alpha=0.5) | pe.StrokeOnly(),\n        # Change the stroke color, set linewidth and alpha, and only stroke (no fill)\n        pattern_fill  # now fill the bar with patterns.\n    ]\n\n    for patch in bars:\n        patch.set_path_effects(path_effects)\n\nax.legend(loc='upper left', ncols=1,\n          handleheight=3., handlelength=3.)"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-we-add-christmas-patterns-from-pattern.monster.",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-we-add-christmas-patterns-from-pattern.monster.",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "# First, you need to know the names of the patterns you are going to use.\n# The python package itself does not provide a good way to browse the patterns.\n# You can list the names of patterns by\npm.names[:10]  # We only show the first 10 items.\n\n['waves-1',\n 'waves-2',\n 'waves-3',\n 'waves-4',\n 'waves-5',\n 'waves-6',\n 'waves-7',\n 'chevron-1',\n 'chevron-2',\n 'chevron-3']\n\n\n\n# names are categorized by roots and tags\npm.roots # outputs are suppressed\npm.tags  # outputs are suppressed"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-lets-apply-the-patterns",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-lets-apply-the-patterns",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "The python package only contains path definition, not colors. And you need to provide suitable colors for your pattern.\nIf color_cycle is not specified, the default color cycle of [“C0”, “C1”, …] will be used.\nIf the given color_cycle contains None, it will be interpreted as the facecolor of the parent artist.\nNote that patterns of pattern_monster are rendered using the custom patheffects. If you are not familiar with patheffect, take a look at patheffects-guide\nThe code below uses mpl-visual-context, but I won’t go into details for its use for now.\n\n\n# pattern names, colors and scale factor. Note that all the pattern names in the python package is in lower-case.\n# The colors also from pattern.monster's pallette, that I think go well with the christmas.\n\npatterns = [(\"christmas-tree-1\",\n             [\"#009688\", \"#E91E63\", \"#03A9F4\", \"#ECC94B\"],\n             1),\n            (\"christmas-pattern-2\",\n             [\"#F6AD55\", \"#E91E63\", \"#03A9F4\"],\n             1.5)]\n\nfor bars, slug_colors_scale in zip(ax.containers, patterns):\n\n    slug, colors, scale = slug_colors_scale\n    pattern = pm.get(slug, scale=scale)  # we get the pattern instance using its name, a scale factor.\n    pattern_fill = pattern.fill(ax, color_cycle=colors, alpha=0.5)\n    # its 'fill' method with return patheffect instance.\n\n    path_effects = [\n        pe.FillColor(colors[0]) | pe.GCModify(alpha=0.3),  # Change the fill color and set alpha to 0.3\n        pe.StrokeColor(colors[0]) | pe.GCModify(linewidth=2, alpha=0.5) | pe.StrokeOnly(),\n        # Change the stroke color, set linewidth and alpha, and only stroke (no fill)\n        pattern_fill  # now fill the bar with patterns.\n    ]\n\n    for patch in bars:\n        patch.set_path_effects(path_effects)\n\nax.legend(loc='upper left', ncols=1,\n          handleheight=3., handlelength=3.)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JJL’s Matplotlib blog",
    "section": "",
    "text": "The source code for these posts (mostly jupyter notebook files converted to plain python using jupytext) should be available at the github repo below.\nhttps://github.com/leejjoon/jjl-mpl-blog\nIf you have any comments on the content of this site, please use github issues, etc.\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nIntroducing mpl-pe-fancy-bar\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-pe-fancy-bar\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nMay 31, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nAlphabet frequency plot\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-poormans-3d\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nMar 25, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nUpgrade your violinplot with mpl-visual-context\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nMar 24, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nmpl-flags : drawing flags with Matplotlib\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-flags\n\n\n\n\n\n\n\n\n\n\n\nMar 18, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nAssembling Multiple Legends into a single box\n\n\n\n\n\n\n\n\n\n\n\n\nFeb 24, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nChristmas Patterns in Matplotlib\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-visual-context\n\n\npatterns\n\n\n\n\n\n\n\n\n\n\n\nDec 27, 2023\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nIntroducing mpl-speech-bubble\n\n\n\n\n\n\n\n\n\n\n\n\nNov 30, 2023\n\n\nJae-Joon Lee\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "README_admin.html",
    "href": "README_admin.html",
    "title": "JJL's Matplotlib blog",
    "section": "",
    "text": "jupytext –set-formats ipynb,py:percent notebook.ipynb jupytext –sync notebook.py\n\n\nquarto preview . quarto render quarto publish gh-pages # you should be in main branch"
  },
  {
    "objectID": "posts/mpl-20231130-intro_speech_bubble/index.html",
    "href": "posts/mpl-20231130-intro_speech_bubble/index.html",
    "title": "Introducing mpl-speech-bubble",
    "section": "",
    "text": "In this post, I will introduce mpl-speech-bubble package.\nYou can install it by\n\npip install mpl-speech-bubble\n\nAnd the source code can be found at https://github.com/leejjoon/mpl-speech-bubble and documentation at https://mpl-speech-bubble.readthedocs.io/ (documentation is far from complete)\nWith mpl-speech-bubble, you can annotate you Matplotlib plot with speech bubbles, like this\n\nLet’s start with a Matplotlib’s annotate example. Note that we use “wedge” arrow style.\n\n%matplotlib inline\n\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(num=1, clear=True)\n\nxy = (0.2, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nannotate_kwargs = dict(\n    ha=\"center\", va=\"bottom\",\n    size=20,\n    bbox=dict(boxstyle=\"round, pad=0.2\",\n              fc=\"w\", ec=\"k\"),\n    arrowprops=dict(\n        arrowstyle=\"wedge, tail_width=0.5\",\n        fc=\"y\",\n        patchA=None, # by default, annotate set patchA to the bbox.\n    )\n)\n\nt = ax.annotate(\n    text=\"Default\",\n    xy=xy, xycoords='data',\n    xytext=(-0., .9), textcoords=\"offset fontsize\",\n    **annotate_kwargs\n)\n\nax.set_xlim(0, 1)\n\n(0.0, 1.0)\n\n\n\n\n\nmpl-speech-bubble has a function annotate_merged. This fucntion is mostly identical to MPL’s annotate, and at the drawing time, it will merge the bbox patch and the arrow patch. Behind the scence, it uses skia-pathops to merge bezier paths. The properties of merged patch will inherid from the bbox patch.\n\nfrom mpl_speech_bubble import annotate_merged\n\nxy = (0.5, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nt = annotate_merged(\n    ax,\n    text=\"Merged\",\n    xy=xy, xycoords='data',\n    xytext=(-0., .9), textcoords=\"offset fontsize\",\n    **annotate_kwargs\n)\n\n\n\n\nIn addtion, it provides annotate-bubble function. It has slghtly different call signature from annotate, but has an advantage of better handling of things like rotation.\nInstead of xytext and textcoords, you should use loc and dist. The unit of dist is fontsize.\n\nfrom mpl_speech_bubble import annotate_bubble\n\nxy = (0.8, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nt = annotate_bubble(\n    ax,\n    text=\"Bubble\",\n    xy=xy, xycoords='data',\n    loc=\"up\", dist=1.,\n    size=20,\n)\n\n\n\n\n\n\n\nt = annotate_bubble(\n    ax,\n    text=\"Bubble 2\",\n    xy=xy, xycoords='data',\n    loc=\"down\", dist=1.,\n    size=20, rotation=30,\n)\n\n\n\n\n\n\nannotate_bubble is a simple wrapper around AnnotationBubble class. Please take a look at the example here"
  },
  {
    "objectID": "posts/mpl-20240324-upgrade-violin-plots/index.html",
    "href": "posts/mpl-20240324-upgrade-violin-plots/index.html",
    "title": "Upgrade your violinplot with mpl-visual-context",
    "section": "",
    "text": "In this post, I will show how you can upgrade your violinplot with mpl-visual-context and make it fancy.\npip install mpl-visual-context\n\n\nCode\n\"\"\"\n====================\nVioling Chart demonstraing various mpl-visual-context features\n====================\n\n\"\"\"\n\n# import numpy as np\nimport matplotlib.pyplot as plt\nimport mpl_visual_context.patheffects as pe\nimport seaborn\n\nseaborn.set()\n\ntips = seaborn.load_dataset(\"tips\")\n\n# We start from a simple seaborn violin plot\nfig, axs = plt.subplots(2, 2, num=1, clear=True, figsize=(8, 6), layout=\"constrained\")\nfor ax in axs.flat:\n    seaborn.violinplot(x='day', y='tip', data=tips, ax=ax,\n                       hue='day', palette=\"deep\")\n\nax = axs[0, 0]\nax.annotate(\n    \"(a) Original violin plot\",\n    (0, 1),\n    xytext=(5, -5),\n    xycoords=\"axes fraction\",\n    va=\"top\",\n    ha=\"left\",\n    textcoords=\"offset points\",  # size=20,\n)\n\n# (b) w/ Brighter fill color\nax = axs[0, 1]\n# We select violin patches. It seems that collections created by violinplot are\n# version dependent. So your mileage may vary.\ncolls = ax.collections[::]\n\n\nax.annotate(\n    \"(b) Make fill color lighter,\\nand stroke with the (original) fill color\",\n    (0, 1),\n    xytext=(5, -5),\n    xycoords=\"axes fraction\",\n    va=\"top\",\n    ha=\"left\",\n    textcoords=\"offset points\",  # size=20,\n)\n\npe_list = [\n    pe.HLSModify(l=0.8) | pe.FillOnly(),\n    pe.StrokeColorFromFillColor() | pe.StrokeOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n# (c) AlphaGradient\nax = axs[1, 0]\ncolls = ax.collections[::]\n\nax.annotate(\n    \"(c) Fill w/ alpha gradient\",\n    (0, 1),\n    xytext=(5, -5),\n    xycoords=\"axes fraction\",\n    va=\"top\",\n    ha=\"left\",\n    textcoords=\"offset points\",  # size=20,\n)\n\npe_list = [\n    pe.AlphaGradient(\"0.8 &gt; 0.2 &gt; 0.8\"),\n    (pe.StrokeColorFromFillColor() | pe.StrokeOnly()),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n# (4) w/ Light effect\nax = axs[1, 1]\ncolls = ax.collections[::]\n\nax.annotate(\n    \"(d) Light effect and shadow\",\n    (0, 1),\n    xytext=(5, -5),\n    xycoords=\"axes fraction\",\n    va=\"top\",\n    ha=\"left\",\n    textcoords=\"offset points\",  # size=20,\n)\n\nimport mpl_visual_context.image_effect as ie\n\npe_list = [\n    # shadow\n    pe.FillOnly()\n    | pe.ImageEffect(\n        ie.AlphaAxb((0.5, 0))\n        | ie.Pad(10)\n        | ie.Fill(\"k\")\n        | ie.Dilation(3)\n        | ie.Gaussian(4)\n        | ie.Offset(3, -3)\n    ),\n    # light effect\n    pe.HLSModify(l=0.7)\n    | pe.FillOnly()\n    | pe.ImageEffect(ie.LightSource(erosion_size=5, gaussian_size=5)),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\n\nWe will start with a seaborn violinplot example.\n\n\n\nimport matplotlib.pyplot as plt\nimport seaborn\n\nseaborn.set()\n\ntips = seaborn.load_dataset(\"tips\")\n\nfig, ax = plt.subplots(num=1, clear=True, figsize=(4, 3), layout=\"constrained\" )\nseaborn.violinplot(x='day', y='tip', data=tips, ax=ax,\n                   hue='day', palette=\"deep\")\n\n&lt;Axes: xlabel='day', ylabel='tip'&gt;\n\n\n\n\n\nWhile there are other ways to change the fill-colors and edge-colors of the patches, in this example, we will use patheffect. There are pros and cons. The disadvantages would be that it will increase the runtime performance. Advantage would be that it will keep its original color.\n\n\nSimple patheffect with mpl-visual-context: change color\nLet’s start with a simple example\nThe default edge color is black, let’s sync it to that of the facecolor. We will use mpl-visual-context module, which implements composable patheffects, i.e., it implements various patheffects that can do simple thins and the can be pipelined to make complex patheffects.\n\n\n\nimport mpl_visual_context.patheffects as pe\n\ncolls = ax.collections\n\npe_list = [\n    pe.HLSModify(l=0.8) | pe.FillOnly()\n]\n\nfor coll in colls:\n    coll.set_path_effects(pe_list)\n\n\nHLSModify change the color (both fillcolor and edgecolor) in the HLS space. It will set the lightness to 0.8, making the color brighter. And, FillOnly will fill the path without stroking. By pipelining two patheffects with |, we create a new pathe effect that fills the path with a lighter color.\nNote that we iterate over ax.collections, but ax.collections seem to have different artists based on the seaborn version. So, you may need to iterate over a subset of collections.\n\n\n\n\n\nset_path_effects takes a list of patheffects. And the same path is drawn with different patheffects in sequence. So, let’s add another patheffect. The default edgecolor was black, and we will change the edgecolor to the original fillcolor. StrokeColorFromFillColor will set the edgecolor to that of fillcolor and StrokeOnly will simply stroke the path without filling.\n\npe_list = [\n    pe.HLSModify(l=0.8) | pe.FillOnly(),\n    pe.StrokeColorFromFillColor() | pe.StrokeOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nmpl-visual-context` contains various patheffects. Check out https://mpl-visual-context.readthedocs.io/en/latest/api_path_effect.html for the list of available patheffects.\n\n\nImage-based patheffects\nmpl-visual-context also contains image-base patheffects. Note that these effects won’t draw the path in vector format. Instead, it will rasterize the path and apply filters in image plane then the image is drawn on the canvas. Therefore, in most case, these image-base patheffect should be placed at the end of the pipeline.\nLet’s apply some alpha gradient to the fill. AlphaGradient will make an image of the fill color and adjust the alpha channel of the images. For example, ‘0.8 &gt; 0.2 &gt; 0.8’ means alpha horizontal gradient starting from 0.8 on the left, 0.2 at the center and 0.8 at the right.\n\n\npe_list = [\n    pe.AlphaGradient(\"0.8 &gt; 0.4 &gt; 0.8\"),\n    pe.StrokeColorFromFillColor() | pe.StrokeOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nYou can also do vertical gradient. Instead of ‘&gt;’ use ‘^’. For example, ‘0.8 ^ 0’ means alpha of 0.8 at the bottom and 0 at the top. Note that the image is created with extent of the artist.\n\n\npe_list = [\n    pe.AlphaGradient(\"0.8 ^ 0\"),\n    pe.StrokeColorFromFillColor() | pe.StrokeOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nAlphaGradient is a special case of an ImageEffect patheffect. In fact, ImageEffect implements various effects in image plane that can be pipelined (similar to patheffects)\n\nimport mpl_visual_context.image_effect as ie\n\ndrop_shadow = pe.ImageEffect(\n    ie.AlphaAxb((0.3, 0))\n    | ie.Pad(10)\n    | ie.Fill(\"k\")\n    | ie.Dilation(3)\n    | ie.Gaussian(3)\n    | ie.Offset(3, 3)\n)\n\npe_list = [\n    drop_shadow\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nTogether with the fill, it could be\n\npe_list = [\n    drop_shadow,\n    pe.FillOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nTo make it more fancy, we can add light effect. It is based on matplotlib.colors.LightSource. https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LightSource.html\n\nlighteffect = (pe.HLSModify(l=0.7)\n               | pe.FillOnly()\n               | pe.ImageEffect(ie.LightSource(erosion_size=5, gaussian_size=5))\n               )\n\npe_list = [\n    lighteffect\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nCombining lighteffect with dropshadow,\n\npe_list = [\n    drop_shadow,\n    lighteffect\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n# plt.show()"
  },
  {
    "objectID": "posts/mpl-20240325-alphabet-frequency-chart/index.html",
    "href": "posts/mpl-20240325-alphabet-frequency-chart/index.html",
    "title": "Alphabet frequency plot",
    "section": "",
    "text": "We will creat plot of alphabet frequency. We will use mpl-poormans-3d package. The package can give your 2d plot some (but limited) 3d feel.\n\n\nCode\nimport numpy as np\nfrom pathlib import Path\nfrom matplotlib.font_manager import FontProperties\n\nfrom matplotlib.colors import LightSource\nfrom mpl_poormans_3d import BarToCharPrism\nimport mpl_visual_context.patheffects as pe\nimport mpl_visual_context.image_effect as ie\n\nimport matplotlib.pyplot as plt\n\nfrom SecretColors import Palette\n\nfig, axs = plt.subplots(2, 1, num=1, clear=True, figsize=(15, 8), layout=\"constrained\")\n\n# alphabet frequency data from wikipedia : https://en.wikipedia.org/wiki/Letter_frequency\n\nabcd = [chr(ord(\"A\") + i) for i in range(26)]  # A - Z\nfreq = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.15, 0.77, 4.0, 2.4, 6.7, 7.5, 1.9,\n        0.095, 6.0, 6.3, 9.1, 2.8, 0.98, 2.4, 0.15, 2.0, 0.074]\n\nax = axs[0]\n\nx = np.arange(len(abcd))\nax.bar(x, freq)\nax.set_xticks(x, abcd)\nax.set_ylim(-1.5, 15)\nax.set_ylabel(\"Frequency [%]\")\n\nls = LightSource(azdeg=25+90)\n\nfp = FontProperties(\"sans serif\")\n\nimport seaborn as sns\ncc = sns.color_palette(\"husl\", 26)\n\nrs = np.random.RandomState(8)\nidx = rs.choice(len(cc), len(cc), replace=False)\ncc = np.array(cc)[idx]\n\nfor p, fc, c in zip(ax.patches, cc, abcd):\n    # p.set_fc(color)\n    bar_to_prism = BarToCharPrism(ls, c,\n                                  ratio=0.6,\n                                  rotate_deg=10,\n                                  fraction=0.5,\n                                  scale=1.2,\n                                  # fontprop=fp,\n                                  distance_mode=np.mean)\n\n    p.set_path_effects([#pe.FillOnly(),\n        (bar_to_prism.get_pe_face(0)\n         | pe.FillColor(\"k\")\n         | pe.ImageEffect(ie.Pad(20) | ie.Fill(\"k\") | ie.GaussianBlur(5))),\n        pe.FillColor(fc) | bar_to_prism,\n        (bar_to_prism.get_pe_face(1)\n         | pe.FillColor(\"w\")\n         ),\n    ])\n\n# from https://story.pxd.co.kr/958, w/o double consonant\nhangul_consonant = \"ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎ\"\nhangul_freq = [11.3, 7.3, 8.0, 6.6, 5.6, 4.8, 9.1, 21.4, 8.3, 2.3, 1.6, 2.2, 1.5, 6.8]\n\nax = axs[1]\n\nimport mplfonts\nfrom mplfonts.conf import FONT_DIR # , RC_DIR\nfrom pathlib import Path\n# fname = Path(FONT_DIR) / \"NotoSansMonoCJKsc-Regular.otf\"\nfname = Path(FONT_DIR) / \"NotoSerifCJKsc-Regular.otf\"\n# fname = Path(FONT_DIR) / \"SourceHanSerifSC-Regular.otf\"\nfp = FontProperties(fname=fname)\n\nx = np.arange(len(hangul_consonant))\nax.bar(x, hangul_freq)\nax.set_xticks(x, hangul_consonant, fontproperties=fp)\nax.set_ylim(-3, 25)\nax.set_ylabel(\"Frequency [%]\")\n\nls = LightSource(azdeg=25+90)\n\nimport seaborn as sns\n\npalette = Palette(\"material\")\ncnames = list(c for c in palette.colors.keys() if c not in [\"black\", \"white\"])\nrs = np.random.RandomState(8)\ncnames = rs.choice(cnames, len(cnames), replace=False)\n\nfor p, cn, c in zip(ax.patches, cnames, hangul_consonant):\n    cc = [palette.get(cn, shade=shade) for shade in np.linspace(20, 90, 50)]\n    segment_params = (ax, 25, cc, None)\n\n    bar_to_prism = BarToCharPrism(ls, c,\n                                  ratio=0.6,\n                                  rotate_deg=10,\n                                  fraction=0.5,\n                                  scale=1.2,\n                                  fontprop=fp,\n                                  segment_params=segment_params,\n                                  distance_mode=np.mean)\n\n    p.set_path_effects([#pe.FillOnly(),\n        (bar_to_prism.get_pe_face(0)\n         | pe.FillColor(\"k\")\n         | pe.ImageEffect(ie.Pad(20) | ie.Fill(\"k\") | ie.GaussianBlur(10))),\n        pe.FillColor(fc) | bar_to_prism,\n        (bar_to_prism.get_pe_face(1)\n         | pe.FillColor(\"w\")\n         ),\n    ])\n\nplt.show()\n\n\n\n\n\n\nmpl-poormans-3d is available at github. It can be installed via\npip install mpl-poormans-3d\nWe will start with a data.\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n# alphabet frequency data from wikipedia : https://en.wikipedia.org/wiki/Letter_frequency\n\nabcd = [chr(ord(\"A\") + i) for i in range(26)]  # A - Z\nfreq = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.15, 0.77, 4.0, 2.4, 6.7, 7.5, 1.9,\n        0.095, 6.0, 6.3, 9.1, 2.8, 0.98, 2.4, 0.15, 2.0, 0.074]\n\nFor the clairty, we will create a sample plot focusing on the first 4 bars. We adjusted y-range also to have enough room for 3d effects.\n\nfig, ax = plt.subplots(1, 1, num=1, clear=True, figsize=(4, 2.5), layout=\"constrained\")\n\nx = np.arange(len(abcd))\nax.bar(x, freq)\nax.set_xticks(x, abcd)\nax.set_ylabel(\"Frequency [%]\")\nax.set_xlim(-0.6, 3.6)\nax.set_ylim(-1.5, 10)\n\n\n\n\n\n\nmpl-poormasn-3d provide a way to convert your bars to 3d. We will first try BarToPrism class. You create it by setting the lightsource and number of vertices of the shape. Its instance is callable object and can be used as a patheffect. The lightsource should be an instance of matplotlib.colors.LightSource.\n\nfrom matplotlib.colors import LightSource\nfrom mpl_poormans_3d import BarToPrism\n\nlightsource = LightSource(azdeg=25+90)\n\np = ax.patches[0]\n\nnumVertices = 4\nbar_to_prism = BarToPrism(lightsource, numVertices)\n\np.set_path_effects([bar_to_prism])\n\n\n\n\n\n\nBarToPrism takes several keyword arguments. ratio is for aspect ratio, i.e., smaller ratio will give you flat shape. The meaning of scale and rotate_deg should be self-explanatory.\n\np = ax.patches[1]\n\nnumVertices = 8\nbar_to_prism = BarToPrism(lightsource, numVertices, ratio=0.2, scale=0.8, rotate_deg=30)\n\np.set_path_effects([bar_to_prism])\n\n\n\n\n\n\nBarToCylinder will creat a cylinder.\n\nfrom mpl_poormans_3d import BarToCylinder\np = ax.patches[2]\n\nbar_to_prism = BarToCylinder(lightsource, ratio=0.4)\n\np.set_path_effects([bar_to_prism])\n\n\n\n\n\n\nBarToCharPrism will creat a 3d-bar using the character path and BarToPathPrism will do the same using an arbitrary path.\n\nfrom mpl_poormans_3d import BarToCharPrism\np = ax.patches[3]\n\nbar_to_prism = BarToCharPrism(lightsource, \"d\")\n\np.set_path_effects([bar_to_prism])\n\n\n\n\n\n\nThe instance of BarToPrism and its siblings have a get_pe_face method which returns a patheffect that only show the face of the prism at a given position. 0 means bottom, 1 means top. Note that an instance of BarToPrism renders multiple paths and cannot be combined with other patheffects. On the other hand, return value of get_pe_face method can be combine with other patheffects, e.g., patheffects from mpl-visual-context.\n\nimport mpl_visual_context.patheffects as pe\n\nbar_to_prism = BarToCharPrism(lightsource, \"d\")\n\np.set_path_effects([\n    bar_to_prism,\n    bar_to_prism.get_pe_face(1) | pe.FillColor(\"w\") | pe.StrokeColor(\"r\")\n])\n\n\n\n\n\n\nWe can further add a simple shadow to the bar.\n\nimport mpl_visual_context.image_effect as ie\n\nblur_effect = pe.ImageEffect(ie.Pad(20) | ie.Fill(\"k\") | ie.GaussianBlur(5))\n\np.set_path_effects([\n    bar_to_prism.get_pe_face(0) | pe.FillColor(\"k\") | blur_effect,\n    bar_to_prism,\n    bar_to_prism.get_pe_face(1) | pe.FillColor(\"w\") | pe.StrokeColor(\"r\")\n])\n\n\n\n\n\n\nNow, let’s create a plot of full character set and show alphabet frequency. We will set the facolor of bars using the te husl color palette.\n\nfig, ax = plt.subplots(1, 1, num=2, clear=True, figsize=(12, 4), layout=\"constrained\")\n\nx = np.arange(len(abcd))\nax.bar(x, freq)\nax.set_xticks(x, abcd)\nax.set_ylabel(\"Frequency [%]\")\n\nimport seaborn as sns\ncc = sns.color_palette(\"husl\", 26)\n\nrs = np.random.RandomState(8)\nidx = rs.choice(len(cc), len(cc), replace=False)\ncc = np.array(cc)[idx]\n\nfor p, fc in zip(ax.patches, cc):\n    p.set_fc(fc)\n\nax.set_ylim(-1.5, 15)\n\n\n\n\n\n\nWe will use BarToCharPrism to represent the alphabet. We will add some shadow and make the top face white.\n\nlightsource = LightSource(azdeg=25+90)\nblur_effect = pe.ImageEffect(ie.Pad(10) | ie.Fill(\"k\") | ie.GaussianBlur(3))\n\nfor p, fc, c in zip(ax.patches, cc, abcd):\n    bar_to_prism = BarToCharPrism(lightsource, c,\n                                  ratio=0.6,\n                                  rotate_deg=10,\n                                  fraction=0.5,\n                                  scale=1.2,\n                                  distance_mode=np.mean)\n\n    p.set_path_effects([#pe.FillOnly(),\n        (bar_to_prism.get_pe_face(0) | pe.FillColor(\"k\") | blur_effect),\n        bar_to_prism,\n        (bar_to_prism.get_pe_face(1) | pe.FillColor(\"w\"))\n    ])\n\n\n\n\n\n\nWe will create another plot, showing frequncy of Hangul characters (Korean characters) We need specify a font with Korean characters. For the example, we will us korean fonts included in the mplfoints package, but any Korean font should work.\nfrom https://story.pxd.co.kr/958, w/o double consonant\n\nhangul_consonant = \"ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎ\"\nhangul_freq = [11.3, 7.3, 8.0, 6.6, 5.6, 4.8, 9.1, 21.4, 8.3, 2.3, 1.6, 2.2, 1.5, 6.8]\n\nfig, ax = plt.subplots(1, 1, num=3, clear=True, figsize=(12, 4), layout=\"constrained\")\n\nfrom mplfonts.conf import FONT_DIR\nfrom pathlib import Path\nfrom matplotlib.font_manager import FontProperties\n\nfname = Path(FONT_DIR) / \"NotoSerifCJKsc-Regular.otf\"\nfp = FontProperties(fname=fname)\n\nx = np.arange(len(hangul_consonant))\nax.bar(x, hangul_freq)\nax.set_xticks(x, hangul_consonant, fontproperties=fp)\nax.set_ylim(-3, 25)\nax.set_ylabel(\"Frequency [%]\")\n\n\n\n\n\n\nWe want the prism to have varuing shades. For that, we will use material palette. We will pick up the palette from the SecretColors package althoug the original palette is from google’s matrial design.\nPrism instances can be created using the semenet_params.\n\nfrom SecretColors import Palette\nimport seaborn as sns\n\nlightsource = LightSource(azdeg=25+90)\n\npalette = Palette(\"material\")\ncnames = list(c for c in palette.colors.keys() if c not in [\"black\", \"white\"])\nrs = np.random.RandomState(8)\ncnames = rs.choice(cnames, len(cnames), replace=False)\n\nblur_effect = pe.ImageEffect(ie.Pad(10) | ie.Fill(\"k\") | ie.GaussianBlur(3))\n\nfor p, cn, c in zip(ax.patches, cnames, hangul_consonant):\n    cc = [palette.get(cn, shade=shade) for shade in np.linspace(20, 90, 50)]\n    segment_params = (ax, 25, cc, None)\n\n    bar_to_prism = BarToCharPrism(lightsource, c,\n                                  ratio=0.6,\n                                  rotate_deg=10,\n                                  fraction=0.5,\n                                  scale=1.4,\n                                  fontprop=fp,\n                                  segment_params=segment_params,\n                                  )\n\n    p.set_path_effects([\n        bar_to_prism.get_pe_face(0) | pe.FillColor(\"k\") | blur_effect,\n        bar_to_prism,\n        bar_to_prism.get_pe_face(1) | pe.FillColor(\"w\"),\n    ])"
  },
  {
    "objectID": "posts/mpl-20240224-multiple-legends/index.html",
    "href": "posts/mpl-20240224-multiple-legends/index.html",
    "title": "Assembling Multiple Legends into a single box",
    "section": "",
    "text": "My solution to https://twitter.com/zh1zh4n6/status/1759823358340825149\nA legend is a collection of OffsetBox instances. You may collect multiple legends and rearange them to your need.\n\nimport matplotlib.pyplot as plt\n\n\nExample of multiple legends\nWe will start with a modified version of the multiple legend example from multiple-legends-on-the-same-axes\nNote that multiple calls of ax.legend will replace an exising legend. To work around this, we manually add the legend artist to the axes using ax.add_artist.\n\n#! echo: false\n\ndef plot(ax):\n    line1, = ax.plot([1, 2, 3], label=\"Line 1\", linestyle='--')\n    line2, = ax.plot([3, 2, 1], label=\"Line 2\", linewidth=4)\n\n    sct1 = ax.scatter([0, 1, 2], [1.5, 4, 2.], label=\"Sct 1\", marker=\"s\")\n    sct2 = ax.scatter([0, 1, 2], [4, 3, 0.5], label=\"Sct 2\", marker=\"^\")\n\n    return [line1, line2], [sct1, sct2]\n\ntitle_props = dict(alignment=\"left\",\n                   title_fontproperties=dict(weight=\"bold\"))\n\nfig, ax = plt.subplots(num=1, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Create a legend for the first set.\nfirst_legend = ax.legend(handles=[line1, sct1], loc='upper right',\n                         title=\"Data 1\", **title_props)\n\n# Add the legend manually to the Axes.\nax.add_artist(first_legend)\n\n# Create another legend for the second.\nax.legend(handles=[line2, sct2], loc='lower right',\n          title=\"Data 2\", **title_props)\n\n&lt;matplotlib.legend.Legend at 0x7fe8cdde6170&gt;\n\n\n\n\n\n\n\nAssembling multiple legends\nIn the modified version below, We will create multiple legend boxes, which will be assemebed into a single offset box. Note that we don’t want individual legends be displayed.\n\nfig, ax = plt.subplots(num=2, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Legend is a collection of offset_box instances, wrapped around with\n# AnchoredOffsetbox. We will create legends and collect the offset_box\n# instances, but without showing them on the screen for now.\noffsetboxes = []\nfor title, handles in [(\"Data 1\", [line1, sct1]),\n                       (\"Data 2\", [line2, sct2])]:\n    leg = ax.legend(handles=handles,\n                        title=title, **title_props)\n    offsetboxes.append(leg._legend_box)\n\nax.legend_.remove() # We don't want the legend to be displayed.\n\nWe now have a list of offset-boxes. One can vertically pack boxes into a single box and place it on the corner of the axes, similar to a legend.\n\n# We will add the collected offsetbox. They first need to be packed in a box.\n# We use `VPacker` which will pack its childrent vertically.\nfrom matplotlib.offsetbox import VPacker, AnchoredOffsetbox\nvp = VPacker(children=offsetboxes, sep=15)\n\n# Then this will be added to the axes using `AnchoredOffsetbox`, which can be\n# placed just like legend.\nob = AnchoredOffsetbox(loc=\"upper right\", bbox_to_anchor=ax.bbox, child=vp)\nax.add_artist(ob)\n\n\n\n\n\n\nOf course it is possible to place the box outside the axes. There are several ways to do this. I will use axes_grid1 toolkit, which I am most familiar with.\nWe will start with a sample example.\n\nfig, ax = plt.subplots(num=3, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Legend is a collection of offset_box instances, wrapped around with\n# AnchoredOffsetbox. We will create legends and collect the offset_box\n# instances, but without showing them on the screen for now.\noffsetboxes = []\nfor title, handles in [(\"Data 1\", [line1, sct1]),\n                       (\"Data 2\", [line2, sct2])]:\n    leg = ax.legend(handles=handles,\n                        title=title, **title_props)\n    offsetboxes.append(leg._legend_box)\n\nax.legend_.remove() # We don't want the legend to be displayed.\n\n\n\nPlacing the box outside of the main axes\nWe will create a new axes on the right side of the main axes. In addtion, we want the width of this axes set to the width of the offset box.\n\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.axes_size import MaxWidth\n\nvp = VPacker(children=offsetboxes, sep=15)\n\ndivider = make_axes_locatable(ax)\nartist_list = [] # we start with an empty artist list.\nax_right = divider.append_axes(\"right\", size=MaxWidth(artist_list), pad=0.1)\n\nob = AnchoredOffsetbox(loc=\"upper left\", bbox_to_anchor=ax_right.bbox, child=vp,\n                       pad=0, borderpad=0)\n\nax_right.add_artist(ob)\n\n# We add `ob` to the artist_list, so that the width of `ax_right` is adjusted.\nartist_list.append(ob)\n\nax_right.set_axis_off()"
  },
  {
    "objectID": "posts/mpl-20240408-fancy-bar-plot/index.html",
    "href": "posts/mpl-20240408-fancy-bar-plot/index.html",
    "title": "Introducing mpl-pe-fancy-bar",
    "section": "",
    "text": "mpl-pe-fancy-bar\nmpl-pe-fancy-bar is a module that includes patheffect classes that can be applied to bar plots created by Matplotlib which will transform the rectangles to other shapes.\nThe source code is available at github and it is pip installable.\n\npip install mpl-pe-fancy-bar\n\nThis was originally meant to be used with a collection of path from SVG, e.g., this example.\nThis tutorial won’t cover usage of SVGs. It will focus on simpler bars focusing on the usage of the module. The example below show the bars you can create with this module, and the rest of the post will provide a tutorial.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Fixing random state for reproducibility\nnp.random.seed(19680)\n\n# Example data\nn = 4\nx_pos = np.arange(n)\nperformance = 5 * np.random.rand(n)\ncolors = [f\"C{i}\" for i in range(n)]\n\nfrom matplotlib.path import Path\nimport mpl_visual_context.patheffects as pe\nfrom mpl_pe_fancy_bar import BarToArrow, BarToRoundBar\nfrom mpl_pe_fancy_bar.bar_with_icon import Icon, BarWithIcon\n\nfig, axs = plt.subplots(2, 2, num=2, clear=True)\n\npe0 = []\n\npe1 = [(pe.RoundCorner(10, i_selector=lambda i: i in [2, 3])\n        | pe.AlphaGradient(\"0.2 ^ 1.\"))]\n\npe2 = [BarToArrow() | pe.AlphaGradient(\"0.2 ^ 1.\")]\n\ncircle = Path.unit_circle()\nicon_circle = Icon((-1, -1, 2, 2), circle)\nbar_with_circle = BarWithIcon(icon_circle, scale=0.6, dh=0.5)\n\npe3 = [\n    BarToRoundBar() | pe.AlphaGradient(\"0.2 ^ 1.\"),\n    bar_with_circle | pe.FillColor(\"w\"),\n]\n\nfor ax, patheffects in zip(axs.flat, [pe0, pe1, pe2, pe3]):\n    bars = ax.bar(x_pos, performance, align='center', alpha=0.7, color=colors)\n\n    for p in bars:\n        p.set_path_effects(patheffects)\n\n\n\n\n\n\n\nMPL’s own bar plot\nWe will set the stage with a simple bar plot.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Fixing random state for reproducibility\nnp.random.seed(19680)\n\n# Example data\nn = 4\nx_pos = np.arange(n)\nperformance = 5 * np.random.rand(n)\ncolors = [f\"C{i}\" for i in range(n)]\n\nfig, ax = plt.subplots(1, 1, num=1, clear=True, figsize=(4, 3))\n\nbars = ax.bar(x_pos, performance, align='center', color=colors)\n\n\n\n\n\n\nThe idea of mpl-pe-fancy-bar is to use patheffects to transform the simple rectangle path, created by matplotlib, to another path. The idea is similar to FancyBox and FancyArrow in matplotlib.\nWe will start with mpl_visual_context module (which is required by mpl-pe-fancy-arrow). mpl_visual_context already contains some patheffects that you can use, and the patheffects of mpl-pe-fancy-bar are compatible with patheffects of mpl_visual_context. For example, mpl_visual_context.patheffects.RoundCorner can be applied to the rectangle path of the bar chart (RoundCorner itself can be applied to any path as far as they are not bezier spline).\n\nimport mpl_visual_context.patheffects as pe\n\npatheffects = [\n    (pe.RoundCorner(10, i_selector=lambda i: i in [2, 3]) # 2nd, and 3rd corners will be rounded.\n     | pe.AlphaGradient(\"0.2 ^ 0.8\")) # the path will be filled with gradient image whose alpha is 0.2\n                                     # at the bottom and 1 at the top.\n]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\n\n\nmpl-pe-fancy-bar\nmpl-pe-fancy-bar module includes simple patheffects (mostly for demonstration purpose).\n\nfrom mpl_pe_fancy_bar import BarToRoundBar\n\npatheffects = [BarToRoundBar() | pe.AlphaGradient(\"0.2 ^ 0.8\")]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\n\nfrom mpl_pe_fancy_bar import BarToArrow\n\npatheffects = [BarToArrow() | pe.AlphaGradient(\"0.2 ^ 0.8\")]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\n\n\nMaking Custom Shape\nThe included shapes are very limited. You are recommended to creat your own shape. We provide a BarTransformBase class. The key method is _get_surface which will take a single argument of bar height. The width of the bar is assumed to be 1 and the scaling will be taken care of automatically.\nThe example below will draw a circle near the top of the rectangle.\n\nfrom mpl_pe_fancy_bar import BarTransformBase, BarToRoundBar\nfrom matplotlib.path import Path\n\nclass CustomBar(BarTransformBase):\n    def __init__(self, radius=0.3,\n                 orientation=\"vertical\"):\n        super().__init__(orientation=orientation)\n        self._radius = radius\n\n    def _get_surface(self, h):\n        circle = Path.circle(center=(0., h-0.5), radius=0.3)\n        return circle\n\npatheffects = [\n    BarToRoundBar() | pe.AlphaGradient(\"0.2 ^ 0.8\"),\n    CustomBar() | pe.FillColor(\"w\"),\n]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\n\n\nAdding Icon\nAnnotating a bar plot with an icon (simple path in this case) seems to be a frequent pattern, so mpl-pe-fancy-bar has its own support for adding an icon (its size will be proportional to the bar width).\n\nfrom mpl_pe_fancy_bar.bar_with_icon import Icon, BarWithIcon\n\ncircle = Path.unit_circle()\nicon_circle = Icon((-1, -1, 2, 2), circle) # the extent of the circle has \n                                           # lower-left boundary of (-1, -1)\n                                           # and size of (2, 2)\nbar_with_circle = BarWithIcon(icon_circle, scale=0.6, dh=0.5)\n\npatheffects = [\n    BarToRoundBar() | pe.AlphaGradient(\"0.2 ^ 0.8\"),\n    bar_with_circle | pe.FillColor(\"w\"),\n]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\nHorizontal bars are also supported, but you need to specify the orientation explictly when creating the patheffetcs.\n\nfig, ax = plt.subplots(1, 1, num=2, clear=True, figsize=(4, 3))\n\ny_pos = x_pos\nbars = ax.barh(y_pos, performance, align='center', color=colors)\n\norientation= \"horizontal\"\n\nbar_with_circle = BarWithIcon(icon_circle, scale=0.6, dh=0.5, orientation=orientation)\n\npatheffects = [\n    BarToRoundBar(orientation=orientation) | pe.AlphaGradient(\"0.2 &gt; 0.8\"),\n    bar_with_circle | pe.FillColor(\"w\"),\n]\nfor p in bars:\n    p.set_path_effects(patheffects)"
  }
]