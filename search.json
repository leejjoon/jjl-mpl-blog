[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "PatternMonster provide a greate collection of patterns in svg format. mpl-pe-pattern-monster is a package that lets you use these patterns in matplotlib. The original svg files are converted to matplotlib path definitions and included as a numpy array.\nThis tutorial will provide a simple example of barchart with christmas-related patterns.\nWe start from a simple barchart Adopted from https://matplotlib.org/stable/gallery/lines_bars_and_markers/barchart.html\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nspecies = (\"Adelie\", \"Chinstrap\", \"Gentoo\")\npenguin_means = {\n    'Bill Depth': (18.35, 18.43, 14.98),\n    'Bill Length': (38.79, 48.83, 47.50),\n}\n\nx = np.arange(len(species))  # the label locations\ntotal_width = 0.7  # total width of the group\ndw = 0.2 # fraction of space between bars in the same group\nwidth = total_width / (len(penguin_means) + dw * (len(penguin_means) - 1))\n\nfig, ax = plt.subplots(num=1, clear=True, figsize=(8, 6))\n\nfor i, (attribute, measurement) in enumerate(penguin_means.items()):\n    offset = width * (1 + dw) * i\n    rects = ax.bar(x - 0.5 * total_width + offset, measurement, width,\n                   label=attribute, align=\"edge\")\n    ax.bar_label(rects, padding=3)\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel('Length (mm)')\nax.set_title('Penguin attributes by species')\nax.set_xticks(x, species)\nax.set_ylim(0, 58)\n\n''\n\n\n\n\n\n\n\n\n# First, you need to know the names of the patterns you are going to use.\n# The python package itself does not provide a good way to browse the patterns.\n# You can list the names of patterns by\npm.names[:10]  # We only show the first 10 items.\n\n['waves-1',\n 'waves-2',\n 'waves-3',\n 'waves-4',\n 'waves-5',\n 'waves-6',\n 'waves-7',\n 'chevron-1',\n 'chevron-2',\n 'chevron-3']\n\n\n\n# names are categorized by roots and tags\npm.roots # outputs are suppressed\npm.tags  # outputs are suppressed\n\n\n\n\n\n\n\n\nThe python package only contains path definition, not colors. And you need to provide suitable colors for your pattern.\nIf color_cycle is not specified, the default color cycle of [“C0”, “C1”, …] will be used.\nIf the given color_cycle contains None, it will be interpreted as the facecolor of the parent artist.\nNote that patterns of pattern_monster are rendered using the custom patheffects. If you are not familiar with patheffect, take a look at patheffects-guide\nThe code below uses mpl-visual-context, but I won’t go into details for its use for now.\n\n\n# pattern names, colors and scale factor. Note that all the pattern names in the python package is in lower-case.\n# The colors also from pattern.monster's pallette, that I think go well with the christmas.\n\npatterns = [(\"christmas-tree-1\",\n             [\"#009688\", \"#E91E63\", \"#03A9F4\", \"#ECC94B\"],\n             1),\n            (\"christmas-pattern-2\",\n             [\"#F6AD55\", \"#E91E63\", \"#03A9F4\"],\n             1.5)]\n\nfor bars, slug_colors_scale in zip(ax.containers, patterns):\n\n    slug, colors, scale = slug_colors_scale\n    pattern = pm.get(slug, scale=scale)  # we get the pattern instance using its name, a scale factor.\n    pattern_fill = pattern.fill(ax, color_cycle=colors, alpha=0.5)\n    # its 'fill' method with return patheffect instance.\n\n    path_effects = [\n        pe.FillColor(colors[0]) | pe.GCModify(alpha=0.3),  # Change the fill color and set alpha to 0.3\n        pe.StrokeColor(colors[0]) | pe.GCModify(linewidth=2, alpha=0.5) | pe.StrokeOnly(),\n        # Change the stroke color, set linewidth and alpha, and only stroke (no fill)\n        pattern_fill  # now fill the bar with patterns.\n    ]\n\n    for patch in bars:\n        patch.set_path_effects(path_effects)\n\nax.legend(loc='upper left', ncols=1,\n          handleheight=3., handlelength=3.)"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-we-add-christmas-patterns-from-pattern.monster.",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-we-add-christmas-patterns-from-pattern.monster.",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "# First, you need to know the names of the patterns you are going to use.\n# The python package itself does not provide a good way to browse the patterns.\n# You can list the names of patterns by\npm.names[:10]  # We only show the first 10 items.\n\n['waves-1',\n 'waves-2',\n 'waves-3',\n 'waves-4',\n 'waves-5',\n 'waves-6',\n 'waves-7',\n 'chevron-1',\n 'chevron-2',\n 'chevron-3']\n\n\n\n# names are categorized by roots and tags\npm.roots # outputs are suppressed\npm.tags  # outputs are suppressed"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-lets-apply-the-patterns",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-lets-apply-the-patterns",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "The python package only contains path definition, not colors. And you need to provide suitable colors for your pattern.\nIf color_cycle is not specified, the default color cycle of [“C0”, “C1”, …] will be used.\nIf the given color_cycle contains None, it will be interpreted as the facecolor of the parent artist.\nNote that patterns of pattern_monster are rendered using the custom patheffects. If you are not familiar with patheffect, take a look at patheffects-guide\nThe code below uses mpl-visual-context, but I won’t go into details for its use for now.\n\n\n# pattern names, colors and scale factor. Note that all the pattern names in the python package is in lower-case.\n# The colors also from pattern.monster's pallette, that I think go well with the christmas.\n\npatterns = [(\"christmas-tree-1\",\n             [\"#009688\", \"#E91E63\", \"#03A9F4\", \"#ECC94B\"],\n             1),\n            (\"christmas-pattern-2\",\n             [\"#F6AD55\", \"#E91E63\", \"#03A9F4\"],\n             1.5)]\n\nfor bars, slug_colors_scale in zip(ax.containers, patterns):\n\n    slug, colors, scale = slug_colors_scale\n    pattern = pm.get(slug, scale=scale)  # we get the pattern instance using its name, a scale factor.\n    pattern_fill = pattern.fill(ax, color_cycle=colors, alpha=0.5)\n    # its 'fill' method with return patheffect instance.\n\n    path_effects = [\n        pe.FillColor(colors[0]) | pe.GCModify(alpha=0.3),  # Change the fill color and set alpha to 0.3\n        pe.StrokeColor(colors[0]) | pe.GCModify(linewidth=2, alpha=0.5) | pe.StrokeOnly(),\n        # Change the stroke color, set linewidth and alpha, and only stroke (no fill)\n        pattern_fill  # now fill the bar with patterns.\n    ]\n\n    for patch in bars:\n        patch.set_path_effects(path_effects)\n\nax.legend(loc='upper left', ncols=1,\n          handleheight=3., handlelength=3.)"
  },
  {
    "objectID": "README_admin.html",
    "href": "README_admin.html",
    "title": "JJL's Matplotlib blog",
    "section": "",
    "text": "jupytext –set-formats ipynb,py:percent notebook.ipynb jupytext –sync notebook.py\n\n\nquarto preview . quarto render quarto publish gh-pages # you should be in main branch"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JJL’s Matplotlib blog",
    "section": "",
    "text": "Christmas Patterns in Matplotlib\n\n\n\n\n\n\n\n\n\n\n\n\nDec 27, 2023\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nIntroducing mpl-speech-bubble\n\n\n\n\n\n\n\n\n\n\n\n\nNov 30, 2023\n\n\nJae-Joon Lee\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/mpl-20231130-intro_speech_bubble/index.html",
    "href": "posts/mpl-20231130-intro_speech_bubble/index.html",
    "title": "Introducing mpl-speech-bubble",
    "section": "",
    "text": "In this post, I will introduce mpl-speech-bubble package.\nYou can install it by\n\npip install mpl-speech-bubble\n\nAnd the source code can be found at https://github.com/leejjoon/mpl-speech-bubble and documentation at https://mpl-speech-bubble.readthedocs.io/ (documentation is far from complete)\nWith mpl-speech-bubble, you can annotate you Matplotlib plot with speech bubbles, like this\n\nLet’s start with a Matplotlib’s annotate example. Note that we use “wedge” arrow style.\n\n%matplotlib inline\n\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(num=1, clear=True)\n\nxy = (0.2, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nannotate_kwargs = dict(\n    ha=\"center\", va=\"bottom\",\n    size=20,\n    bbox=dict(boxstyle=\"round, pad=0.2\",\n              fc=\"w\", ec=\"k\"),\n    arrowprops=dict(\n        arrowstyle=\"wedge, tail_width=0.5\",\n        fc=\"y\",\n        patchA=None, # by default, annotate set patchA to the bbox.\n    )\n)\n\nt = ax.annotate(\n    text=\"Default\",\n    xy=xy, xycoords='data',\n    xytext=(-0., .9), textcoords=\"offset fontsize\",\n    **annotate_kwargs\n)\n\nax.set_xlim(0, 1)\n\n(0.0, 1.0)\n\n\n\n\n\nmpl-speech-bubble has a function annotate_merged. This fucntion is mostly identical to MPL’s annotate, and at the drawing time, it will merge the bbox patch and the arrow patch. Behind the scence, it uses skia-pathops to merge bezier paths. The properties of merged patch will inherid from the bbox patch.\n\nfrom mpl_speech_bubble import annotate_merged\n\nxy = (0.5, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nt = annotate_merged(\n    ax,\n    text=\"Merged\",\n    xy=xy, xycoords='data',\n    xytext=(-0., .9), textcoords=\"offset fontsize\",\n    **annotate_kwargs\n)\n\n\n\n\nIn addtion, it provides annotate-bubble function. It has slghtly different call signature from annotate, but has an advantage of better handling of things like rotation.\nInstead of xytext and textcoords, you should use loc and dist. The unit of dist is fontsize.\n\nfrom mpl_speech_bubble import annotate_bubble\n\nxy = (0.8, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nt = annotate_bubble(\n    ax,\n    text=\"Bubble\",\n    xy=xy, xycoords='data',\n    loc=\"up\", dist=1.,\n    size=20,\n)\n\n\n\n\n\n\n\nt = annotate_bubble(\n    ax,\n    text=\"Bubble 2\",\n    xy=xy, xycoords='data',\n    loc=\"down\", dist=1.,\n    size=20, rotation=30,\n)\n\n\n\n\n\n\nannotate_bubble is a simple wrapper around AnnotationBubble class. Please take a look at the example here"
  }
]