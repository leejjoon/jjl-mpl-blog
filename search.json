[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/mpl-20240408-fancy-bar-plot/index.html",
    "href": "posts/mpl-20240408-fancy-bar-plot/index.html",
    "title": "Introducing mpl-pe-fancy-bar",
    "section": "",
    "text": "mpl-pe-fancy-bar\nmpl-pe-fancy-bar is a module that includes patheffect classes that can be applied to bar plots created by Matplotlib which will transform the rectangles to other shapes.\nThe source code is available at github and it is pip installable.\n\npip install mpl-pe-fancy-bar\n\nThis was originally meant to be used with a collection of path from SVG, e.g., this example.\nThis tutorial won’t cover usage of SVGs. It will focus on simpler bars focusing on the usage of the module. The example below show the bars you can create with this module, and the rest of the post will provide a tutorial.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Fixing random state for reproducibility\nnp.random.seed(19680)\n\n# Example data\nn = 4\nx_pos = np.arange(n)\nperformance = 5 * np.random.rand(n)\ncolors = [f\"C{i}\" for i in range(n)]\n\nfrom matplotlib.path import Path\nimport mpl_visual_context.patheffects as pe\nfrom mpl_pe_fancy_bar import BarToArrow, BarToRoundBar\nfrom mpl_pe_fancy_bar.bar_with_icon import Icon, BarWithIcon\n\nfig, axs = plt.subplots(2, 2, num=2, clear=True)\n\npe0 = []\n\npe1 = [(pe.RoundCorner(10, i_selector=lambda i: i in [2, 3])\n        | pe.AlphaGradient(\"0.2 ^ 1.\"))]\n\npe2 = [BarToArrow() | pe.AlphaGradient(\"0.2 ^ 1.\")]\n\ncircle = Path.unit_circle()\nicon_circle = Icon((-1, -1, 2, 2), circle)\nbar_with_circle = BarWithIcon(icon_circle, scale=0.6, dh=0.5)\n\npe3 = [\n    BarToRoundBar() | pe.AlphaGradient(\"0.2 ^ 1.\"),\n    bar_with_circle | pe.FillColor(\"w\"),\n]\n\nfor ax, patheffects in zip(axs.flat, [pe0, pe1, pe2, pe3]):\n    bars = ax.bar(x_pos, performance, align='center', alpha=0.7, color=colors)\n\n    for p in bars:\n        p.set_path_effects(patheffects)\n\n\n\n\n\n\n\nMPL’s own bar plot\nWe will set the stage with a simple bar plot.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Fixing random state for reproducibility\nnp.random.seed(19680)\n\n# Example data\nn = 4\nx_pos = np.arange(n)\nperformance = 5 * np.random.rand(n)\ncolors = [f\"C{i}\" for i in range(n)]\n\nfig, ax = plt.subplots(1, 1, num=1, clear=True, figsize=(4, 3))\n\nbars = ax.bar(x_pos, performance, align='center', color=colors)\n\n\n\n\n\n\nThe idea of mpl-pe-fancy-bar is to use patheffects to transform the simple rectangle path, created by matplotlib, to another path. The idea is similar to FancyBox and FancyArrow in matplotlib.\nWe will start with mpl_visual_context module (which is required by mpl-pe-fancy-arrow). mpl_visual_context already contains some patheffects that you can use, and the patheffects of mpl-pe-fancy-bar are compatible with patheffects of mpl_visual_context. For example, mpl_visual_context.patheffects.RoundCorner can be applied to the rectangle path of the bar chart (RoundCorner itself can be applied to any path as far as they are not bezier spline).\n\nimport mpl_visual_context.patheffects as pe\n\npatheffects = [\n    (pe.RoundCorner(10, i_selector=lambda i: i in [2, 3]) # 2nd, and 3rd corners will be rounded.\n     | pe.AlphaGradient(\"0.2 ^ 0.8\")) # the path will be filled with gradient image whose alpha is 0.2\n                                     # at the bottom and 1 at the top.\n]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\n\n\nmpl-pe-fancy-bar\nmpl-pe-fancy-bar module includes simple patheffects (mostly for demonstration purpose).\n\nfrom mpl_pe_fancy_bar import BarToRoundBar\n\npatheffects = [BarToRoundBar() | pe.AlphaGradient(\"0.2 ^ 0.8\")]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\n\nfrom mpl_pe_fancy_bar import BarToArrow\n\npatheffects = [BarToArrow() | pe.AlphaGradient(\"0.2 ^ 0.8\")]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\n\n\nMaking Custom Shape\nThe included shapes are very limited. You are recommended to creat your own shape. We provide a BarTransformBase class. The key method is _get_surface which will take a single argument of bar height. The width of the bar is assumed to be 1 and the scaling will be taken care of automatically.\nThe example below will draw a circle near the top of the rectangle.\n\nfrom mpl_pe_fancy_bar import BarTransformBase, BarToRoundBar\nfrom matplotlib.path import Path\n\nclass CustomBar(BarTransformBase):\n    def __init__(self, radius=0.3,\n                 orientation=\"vertical\"):\n        super().__init__(orientation=orientation)\n        self._radius = radius\n\n    def _get_surface(self, h):\n        circle = Path.circle(center=(0., h-0.5), radius=0.3)\n        return circle\n\npatheffects = [\n    BarToRoundBar() | pe.AlphaGradient(\"0.2 ^ 0.8\"),\n    CustomBar() | pe.FillColor(\"w\"),\n]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\n\n\nAdding Icon\nAnnotating a bar plot with an icon (simple path in this case) seems to be a frequent pattern, so mpl-pe-fancy-bar has its own support for adding an icon (its size will be proportional to the bar width).\n\nfrom mpl_pe_fancy_bar.bar_with_icon import Icon, BarWithIcon\n\ncircle = Path.unit_circle()\nicon_circle = Icon((-1, -1, 2, 2), circle) # the extent of the circle has \n                                           # lower-left boundary of (-1, -1)\n                                           # and size of (2, 2)\nbar_with_circle = BarWithIcon(icon_circle, scale=0.6, dh=0.5)\n\npatheffects = [\n    BarToRoundBar() | pe.AlphaGradient(\"0.2 ^ 0.8\"),\n    bar_with_circle | pe.FillColor(\"w\"),\n]\nfor p in bars:\n    p.set_path_effects(patheffects)\n\n\n\n\n\n\nHorizontal bars are also supported, but you need to specify the orientation explictly when creating the patheffetcs.\n\nfig, ax = plt.subplots(1, 1, num=2, clear=True, figsize=(4, 3))\n\ny_pos = x_pos\nbars = ax.barh(y_pos, performance, align='center', color=colors)\n\norientation= \"horizontal\"\n\nbar_with_circle = BarWithIcon(icon_circle, scale=0.6, dh=0.5, orientation=orientation)\n\npatheffects = [\n    BarToRoundBar(orientation=orientation) | pe.AlphaGradient(\"0.2 &gt; 0.8\"),\n    bar_with_circle | pe.FillColor(\"w\"),\n]\nfor p in bars:\n    p.set_path_effects(patheffects)"
  },
  {
    "objectID": "posts/mpl-20241107-car-crash-plot-with-fancy-bar/index.html",
    "href": "posts/mpl-20241107-car-crash-plot-with-fancy-bar/index.html",
    "title": "Car crash chart: a step-by-step guide",
    "section": "",
    "text": "Decorate your matplotlib bar charts : step-by-step guide\nThis is another guide to decorate matplotlib bar charts. We will basically apply path effects, using packages like mpl-visual-context and mpl_pe_fancy_bar. And we will do it step by step.\n\n\nCode\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set_theme(style=\"whitegrid\")\n\n# Load the example car crash dataset\ncrashes = sns.load_dataset(\"car_crashes\").sort_values(\"total\", ascending=False).iloc[:10]\n\n# Initialize the matplotlib figure\nfig, ax = plt.subplots(num=1, clear=True, figsize=(5, 4), layout=\"constrained\")\n# fig, ax = plt.subplots(num=1, clear=True, layout=\"constrained\")\n\n# Plot the total crashes\nsns.set_color_codes(\"pastel\")\nsns.barplot(x=\"total\", y=\"abbrev\", data=crashes,\n            label=\"Total\", color=\"b\")\n\n# Plot the crashes where alcohol was involved\nsns.set_color_codes(\"muted\")\nsns.barplot(x=\"alcohol\", y=\"abbrev\", data=crashes,\n            label=\"Alcohol-involved\", color=\"b\")\n\n# Add a legend and informative axis label\nax.legend(ncol=2, loc=\"lower right\", frameon=True,\n          bbox_to_anchor=[1, 1])\n\nax.set(xlim=(0, 24.8),\n       ylim=(9.6, -0.6),\n       ylabel=\"\",\n       xlabel=\"Automobile collisions per billion miles\")\n\nsns.despine(left=True, bottom=True)\n\nimport mpl_visual_context.patheffects as pe\nfrom mpl_pe_fancy_bar import BarToRoundBar\nfrom mpl_visual_context.patheffects_shadow import ShadowPath\n\nround_bar = BarToRoundBar(orientation=\"horizontal\", dh=0.5)\nshadow = ShadowPath(115, 3)\n\nfrom svgpath2mpl import parse_path\n\n# car icon from https://fontawesome.com/icons/car?f=classic&s=solid\n# 512 x 512\ns_car = \"M135.2 117.4L109.1 192H402.9l-26.1-74.6C372.3 104.6 360.2 96 346.6 96H165.4c-13.6 0-25.7 8.6-30.2 21.4zM39.6 196.8L74.8 96.3C88.3 57.8 124.6 32 165.4 32H346.6c40.8 0 77.1 25.8 90.6 64.3l35.2 100.5c23.2 9.6 39.6 32.5 39.6 59.2V400v48c0 17.7-14.3 32-32 32H448c-17.7 0-32-14.3-32-32V400H96v48c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32V400 256c0-26.7 16.4-49.6 39.6-59.2zM128 288a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm288 32a32 32 0 1 0 0-64 32 32 0 1 0 0 64z\"\ns_wine = \"M32 0C19.1 0 7.4 7.8 2.4 19.8s-2.2 25.7 6.9 34.9L224 269.3 224 448l-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-178.7L502.6 54.6c9.2-9.2 11.9-22.9 6.9-34.9S492.9 0 480 0L32 0zM173.3 128l-64-64 293.5 0-64 64-165.5 0z\"\n\nicon_car = parse_path(s_car)\nicon_wine = parse_path(s_wine)\n\nfrom mpl_pe_fancy_bar.bar_with_icon import Icon, BarWithIcon\n\nwith_icon_car = BarWithIcon(Icon((512, 512), icon_car), orientation=\"horizontal\", scale=0.5, dh=0.6)\nwith_icon_wine = BarWithIcon(Icon((512, 512), icon_wine), orientation=\"horizontal\", scale=0.5, dh=0.6)\n\npe1 = [\n    round_bar,\n    round_bar | pe.ClipPathSelf() | shadow | pe.HLSModify(l=\"70%\"),\n    with_icon_car | shadow | pe.HLSModify(l=\"50%\"),\n    with_icon_car | pe.FillColor(\"w\")\n]\nfor p in ax.containers[0]:\n    p.set_path_effects(pe1)\n\npe2 = [\n    round_bar | pe.FillOnly(),\n    with_icon_wine | pe.FillColor(\"w\")\n]\nfor p in ax.containers[1]:\n    p.set_path_effects(pe2)\n\nfrom mpl_visual_context.axes_panel import InsetDivider, add_panel\nfrom mpl_visual_context.legend_helper import (\n    extract_offset_boxes_from_legend,\n)\nfrom matplotlib.offsetbox import HPacker\nfrom matplotlib.offsetbox import AnchoredOffsetbox\n\ndivider = InsetDivider(ax)\n\npanel = add_panel(divider, \"left\", \"ticklabels\", pad=0.0)\nlegend_panel = add_panel(divider, \"top\", \"empty\", pad=0.0)\n\nleg_title, oblist = extract_offset_boxes_from_legend(ax.legend_)\n\npack = HPacker(pad=0.0, sep=10, children=oblist)\nbox = AnchoredOffsetbox(\"upper center\", child=pack, pad=0, frameon=False)\nax.legend_.remove()\n\nlegend_panel.add_artist(box)\nlegend_panel.add_to_extent_list(box)\nlegend_panel.grid(False)\n\npanel.set_axis_off()\n\nfc = \"gold\"\nfig.patch.set_fc(fc)\nax.patch.set_visible(False) # fc(fc)\n\n\n\n\n\n\n\n\nA seaborn barplot : a starting point\nThe starting plot is based on this seaborn example\n\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set_theme(style=\"whitegrid\")\n\n# Load the example car crash dataset\ncrashes = sns.load_dataset(\"car_crashes\").sort_values(\"total\", ascending=False).iloc[:10]\n\n# Initialize the matplotlib figure\nfig, ax = plt.subplots(num=1, clear=True, figsize=(5, 4), layout=\"constrained\")\nfc = \"gold\"\nfig.patch.set_fc(fc)\nax.patch.set_visible(False) # fc(fc)\n\n# Plot the total crashes\nsns.set_color_codes(\"pastel\")\nsns.barplot(x=\"total\", y=\"abbrev\", data=crashes,\n            label=\"Total\", color=\"b\")\n\n# Plot the crashes where alcohol was involved\nsns.set_color_codes(\"muted\")\nsns.barplot(x=\"alcohol\", y=\"abbrev\", data=crashes,\n            label=\"Alcohol-involved\", color=\"b\")\n\n# Add a legend and informative axis label\nax.legend(ncol=2, loc=\"lower right\", frameon=True,\n          bbox_to_anchor=[1, 1])\n\nax.set(xlim=(0, 24.8),\n       ylim=(9.6, -0.6),\n       ylabel=\"\",\n       xlabel=\"Automobile collisions per billion miles\")\n\nsns.despine(left=True, bottom=True)\n\n\n\n\n\n\nMake it round\nmpl-pe-fancy-bar module contains patheffects that transform a simple rectangle path to a more complicated one. Below, we will use BarToRoundBar that transform a rectabngle to a rounded one. We will also use patheffects from the mpl-visual-context. FillOnly will only fill the path without a stroke.\n\nimport mpl_visual_context.patheffects as pe\nfrom mpl_pe_fancy_bar import BarToRoundBar\n\nbar_containers_total = ax.containers[0]\nbar_containers_alcohol = ax.containers[1]\n\nround_bar = BarToRoundBar(orientation=\"horizontal\", dh=0.5)\n\npe1 = [\n    round_bar,\n]\nfor p in bar_containers_total:\n    p.set_path_effects(pe1)\n\npe2 = [\n    round_bar | pe.FillOnly(),\n]\nfor p in bar_containers_alcohol:\n    p.set_path_effects(pe2)\n\n\n\n\n\n\n\n\nSimple debossing effect\nWe will add naive debossing effect by adding a shadow effect that is clipped by the path itself. Note the order of clipping and the shdow. The clip path effect will copy the current path, so the clipping path won’t be affected by any path transformation in the downstream. The shadow patheffect will result in the path that can be filled to give some shadow effect (e.g., this example )\n\nfrom mpl_visual_context.patheffects_shadow import ShadowPath\nshadow = ShadowPath(115, 3)\n\npe1 = [\n    round_bar,\n    round_bar | pe.ClipPathSelf() | shadow | pe.HLSModify(l=\"70%\"),\n]\nfor p in bar_containers_total:\n    p.set_path_effects(pe1)\n\npe2 = [\n    round_bar | pe.FillOnly(),\n]\nfor p in bar_containers_alcohol:\n    p.set_path_effects(pe2)\n\n\n\n\n\n\n\n\nAdd SVG Icons\nLet’s add car icons to the bars. There could be different ways. We use BarWithIcon class. The advantage of this is that the size of icon will automatically scale relative to the width of the bars.\n\nfrom svgpath2mpl import parse_path\n\n# car icon from https://fontawesome.com/icons/car?f=classic&s=solid\n# 512 x 512\ns_car = \"M135.2 117.4L109.1 192H402.9l-26.1-74.6C372.3 104.6 360.2 96 346.6 96H165.4c-13.6 0-25.7 8.6-30.2 21.4zM39.6 196.8L74.8 96.3C88.3 57.8 124.6 32 165.4 32H346.6c40.8 0 77.1 25.8 90.6 64.3l35.2 100.5c23.2 9.6 39.6 32.5 39.6 59.2V400v48c0 17.7-14.3 32-32 32H448c-17.7 0-32-14.3-32-32V400H96v48c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32V400 256c0-26.7 16.4-49.6 39.6-59.2zM128 288a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm288 32a32 32 0 1 0 0-64 32 32 0 1 0 0 64z\"\n\ns_wine = \"M32 0C19.1 0 7.4 7.8 2.4 19.8s-2.2 25.7 6.9 34.9L224 269.3 224 448l-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-178.7L502.6 54.6c9.2-9.2 11.9-22.9 6.9-34.9S492.9 0 480 0L32 0zM173.3 128l-64-64 293.5 0-64 64-165.5 0z\"\n\nicon_car = parse_path(s_car)\nicon_wine = parse_path(s_wine)\n\nfrom matplotlib.path import Path\nfrom mpl_pe_fancy_bar.bar_with_icon import Icon, BarWithIcon\n\nwith_car = BarWithIcon(Icon((512, 512), icon_car),\n                       orientation=\"horizontal\", scale=0.5, dh=0.6)\nwith_wine = BarWithIcon(Icon((512, 512), icon_wine),\n                        orientation=\"horizontal\", scale=0.5, dh=0.6)\n\npe1 = [\n    round_bar,\n    round_bar | pe.ClipPathSelf() | shadow | pe.HLSModify(l=\"70%\"),\n    with_car | shadow | pe.HLSModify(l=\"50%\"),\n    with_car | pe.FillColor(\"w\")\n]\nfor p in bar_containers_total:\n    p.set_path_effects(pe1)\n\npe2 = [\n    round_bar | pe.FillOnly(),\n    with_wine | pe.FillColor(\"w\")\n]\nfor p in bar_containers_alcohol:\n    p.set_path_effects(pe2)\n\n\n\n\n\n\nWe will also change the look of legend. We will use panel feature of mpl_visual_context, which we won’t address its detail. In short, panel is an axes that is located next to the main axes, which is meant to display ticks and labels as annotations for more flexibility. Take a look at these examples (ex1 and ex2).\n\nfrom mpl_visual_context.axes_panel import InsetDivider, add_panel\nfrom mpl_visual_context.legend_helper import (\n    extract_offset_boxes_from_legend,\n)\nfrom matplotlib.offsetbox import HPacker\nfrom matplotlib.offsetbox import AnchoredOffsetbox\n\ndivider = InsetDivider(ax)\n\npanel = add_panel(divider, \"left\", \"ticklabels\", pad=0.0)\nlegend_panel = add_panel(divider, \"top\", \"empty\", pad=0.0)\n\nleg_title, oblist = extract_offset_boxes_from_legend(ax.legend_)\n\npack = HPacker(pad=0.0, sep=10, children=oblist)\nbox = AnchoredOffsetbox(\"upper center\", child=pack, pad=0, frameon=False)\nax.legend_.remove()\n\nlegend_panel.add_artist(box)\nlegend_panel.add_to_extent_list(box)\nlegend_panel.grid(False)\n\npanel.set_axis_off()"
  },
  {
    "objectID": "posts/mpl-20240224-multiple-legends/index.html",
    "href": "posts/mpl-20240224-multiple-legends/index.html",
    "title": "Assembling Multiple Legends into a single box",
    "section": "",
    "text": "My solution to https://twitter.com/zh1zh4n6/status/1759823358340825149\nA legend is a collection of OffsetBox instances. You may collect multiple legends and rearange them to your need.\n\nimport matplotlib.pyplot as plt\n\n\nExample of multiple legends\nWe will start with a modified version of the multiple legend example from multiple-legends-on-the-same-axes\nNote that multiple calls of ax.legend will replace an exising legend. To work around this, we manually add the legend artist to the axes using ax.add_artist.\n\n#! echo: false\n\ndef plot(ax):\n    line1, = ax.plot([1, 2, 3], label=\"Line 1\", linestyle='--')\n    line2, = ax.plot([3, 2, 1], label=\"Line 2\", linewidth=4)\n\n    sct1 = ax.scatter([0, 1, 2], [1.5, 4, 2.], label=\"Sct 1\", marker=\"s\")\n    sct2 = ax.scatter([0, 1, 2], [4, 3, 0.5], label=\"Sct 2\", marker=\"^\")\n\n    return [line1, line2], [sct1, sct2]\n\ntitle_props = dict(alignment=\"left\",\n                   title_fontproperties=dict(weight=\"bold\"))\n\nfig, ax = plt.subplots(num=1, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Create a legend for the first set.\nfirst_legend = ax.legend(handles=[line1, sct1], loc='upper right',\n                         title=\"Data 1\", **title_props)\n\n# Add the legend manually to the Axes.\nax.add_artist(first_legend)\n\n# Create another legend for the second.\nax.legend(handles=[line2, sct2], loc='lower right',\n          title=\"Data 2\", **title_props)\n\n&lt;matplotlib.legend.Legend at 0x7fe8cdde6170&gt;\n\n\n\n\n\n\n\nAssembling multiple legends\nIn the modified version below, We will create multiple legend boxes, which will be assemebed into a single offset box. Note that we don’t want individual legends be displayed.\n\nfig, ax = plt.subplots(num=2, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Legend is a collection of offset_box instances, wrapped around with\n# AnchoredOffsetbox. We will create legends and collect the offset_box\n# instances, but without showing them on the screen for now.\noffsetboxes = []\nfor title, handles in [(\"Data 1\", [line1, sct1]),\n                       (\"Data 2\", [line2, sct2])]:\n    leg = ax.legend(handles=handles,\n                        title=title, **title_props)\n    offsetboxes.append(leg._legend_box)\n\nax.legend_.remove() # We don't want the legend to be displayed.\n\nWe now have a list of offset-boxes. One can vertically pack boxes into a single box and place it on the corner of the axes, similar to a legend.\n\n# We will add the collected offsetbox. They first need to be packed in a box.\n# We use `VPacker` which will pack its childrent vertically.\nfrom matplotlib.offsetbox import VPacker, AnchoredOffsetbox\nvp = VPacker(children=offsetboxes, sep=15)\n\n# Then this will be added to the axes using `AnchoredOffsetbox`, which can be\n# placed just like legend.\nob = AnchoredOffsetbox(loc=\"upper right\", bbox_to_anchor=ax.bbox, child=vp)\nax.add_artist(ob)\n\n\n\n\n\n\nOf course it is possible to place the box outside the axes. There are several ways to do this. I will use axes_grid1 toolkit, which I am most familiar with.\nWe will start with a sample example.\n\nfig, ax = plt.subplots(num=3, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Legend is a collection of offset_box instances, wrapped around with\n# AnchoredOffsetbox. We will create legends and collect the offset_box\n# instances, but without showing them on the screen for now.\noffsetboxes = []\nfor title, handles in [(\"Data 1\", [line1, sct1]),\n                       (\"Data 2\", [line2, sct2])]:\n    leg = ax.legend(handles=handles,\n                        title=title, **title_props)\n    offsetboxes.append(leg._legend_box)\n\nax.legend_.remove() # We don't want the legend to be displayed.\n\n\n\nPlacing the box outside of the main axes\nWe will create a new axes on the right side of the main axes. In addtion, we want the width of this axes set to the width of the offset box.\n\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.axes_size import MaxWidth\n\nvp = VPacker(children=offsetboxes, sep=15)\n\ndivider = make_axes_locatable(ax)\nartist_list = [] # we start with an empty artist list.\nax_right = divider.append_axes(\"right\", size=MaxWidth(artist_list), pad=0.1)\n\nob = AnchoredOffsetbox(loc=\"upper left\", bbox_to_anchor=ax_right.bbox, child=vp,\n                       pad=0, borderpad=0)\n\nax_right.add_artist(ob)\n\n# We add `ob` to the artist_list, so that the width of `ax_right` is adjusted.\nartist_list.append(ob)\n\nax_right.set_axis_off()"
  },
  {
    "objectID": "posts/mpl-20240325-alphabet-frequency-chart/index.html",
    "href": "posts/mpl-20240325-alphabet-frequency-chart/index.html",
    "title": "Alphabet frequency plot",
    "section": "",
    "text": "We will creat plot of alphabet frequency. We will use mpl-poormans-3d package. The package can give your 2d plot some (but limited) 3d feel.\n\n\nCode\nimport numpy as np\nfrom pathlib import Path\nfrom matplotlib.font_manager import FontProperties\n\nfrom matplotlib.colors import LightSource\nfrom mpl_poormans_3d import BarToCharPrism\nimport mpl_visual_context.patheffects as pe\nimport mpl_visual_context.image_effect as ie\n\nimport matplotlib.pyplot as plt\n\nfrom SecretColors import Palette\n\nfig, axs = plt.subplots(2, 1, num=1, clear=True, figsize=(15, 8), layout=\"constrained\")\n\n# alphabet frequency data from wikipedia : https://en.wikipedia.org/wiki/Letter_frequency\n\nabcd = [chr(ord(\"A\") + i) for i in range(26)]  # A - Z\nfreq = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.15, 0.77, 4.0, 2.4, 6.7, 7.5, 1.9,\n        0.095, 6.0, 6.3, 9.1, 2.8, 0.98, 2.4, 0.15, 2.0, 0.074]\n\nax = axs[0]\n\nx = np.arange(len(abcd))\nax.bar(x, freq)\nax.set_xticks(x, abcd)\nax.set_ylim(-1.5, 15)\nax.set_ylabel(\"Frequency [%]\")\n\nls = LightSource(azdeg=25+90)\n\nfp = FontProperties(\"sans serif\")\n\nimport seaborn as sns\ncc = sns.color_palette(\"husl\", 26)\n\nrs = np.random.RandomState(8)\nidx = rs.choice(len(cc), len(cc), replace=False)\ncc = np.array(cc)[idx]\n\nfor p, fc, c in zip(ax.patches, cc, abcd):\n    # p.set_fc(color)\n    bar_to_prism = BarToCharPrism(ls, c,\n                                  ratio=0.6,\n                                  rotate_deg=10,\n                                  fraction=0.5,\n                                  scale=1.2,\n                                  # fontprop=fp,\n                                  distance_mode=np.mean)\n\n    p.set_path_effects([#pe.FillOnly(),\n        (bar_to_prism.get_pe_face(0)\n         | pe.FillColor(\"k\")\n         | pe.ImageEffect(ie.Pad(20) | ie.Fill(\"k\") | ie.GaussianBlur(5))),\n        pe.FillColor(fc) | bar_to_prism,\n        (bar_to_prism.get_pe_face(1)\n         | pe.FillColor(\"w\")\n         ),\n    ])\n\n# from https://story.pxd.co.kr/958, w/o double consonant\nhangul_consonant = \"ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎ\"\nhangul_freq = [11.3, 7.3, 8.0, 6.6, 5.6, 4.8, 9.1, 21.4, 8.3, 2.3, 1.6, 2.2, 1.5, 6.8]\n\nax = axs[1]\n\nimport mplfonts\nfrom mplfonts.conf import FONT_DIR # , RC_DIR\nfrom pathlib import Path\n# fname = Path(FONT_DIR) / \"NotoSansMonoCJKsc-Regular.otf\"\nfname = Path(FONT_DIR) / \"NotoSerifCJKsc-Regular.otf\"\n# fname = Path(FONT_DIR) / \"SourceHanSerifSC-Regular.otf\"\nfp = FontProperties(fname=fname)\n\nx = np.arange(len(hangul_consonant))\nax.bar(x, hangul_freq)\nax.set_xticks(x, hangul_consonant, fontproperties=fp)\nax.set_ylim(-3, 25)\nax.set_ylabel(\"Frequency [%]\")\n\nls = LightSource(azdeg=25+90)\n\nimport seaborn as sns\n\npalette = Palette(\"material\")\ncnames = list(c for c in palette.colors.keys() if c not in [\"black\", \"white\"])\nrs = np.random.RandomState(8)\ncnames = rs.choice(cnames, len(cnames), replace=False)\n\nfor p, cn, c in zip(ax.patches, cnames, hangul_consonant):\n    cc = [palette.get(cn, shade=shade) for shade in np.linspace(20, 90, 50)]\n    segment_params = (ax, 25, cc, None)\n\n    bar_to_prism = BarToCharPrism(ls, c,\n                                  ratio=0.6,\n                                  rotate_deg=10,\n                                  fraction=0.5,\n                                  scale=1.2,\n                                  fontprop=fp,\n                                  segment_params=segment_params,\n                                  distance_mode=np.mean)\n\n    p.set_path_effects([#pe.FillOnly(),\n        (bar_to_prism.get_pe_face(0)\n         | pe.FillColor(\"k\")\n         | pe.ImageEffect(ie.Pad(20) | ie.Fill(\"k\") | ie.GaussianBlur(10))),\n        pe.FillColor(fc) | bar_to_prism,\n        (bar_to_prism.get_pe_face(1)\n         | pe.FillColor(\"w\")\n         ),\n    ])\n\nplt.show()\n\n\n\n\n\n\nmpl-poormans-3d is available at github. It can be installed via\npip install mpl-poormans-3d\nWe will start with a data.\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n# alphabet frequency data from wikipedia : https://en.wikipedia.org/wiki/Letter_frequency\n\nabcd = [chr(ord(\"A\") + i) for i in range(26)]  # A - Z\nfreq = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.15, 0.77, 4.0, 2.4, 6.7, 7.5, 1.9,\n        0.095, 6.0, 6.3, 9.1, 2.8, 0.98, 2.4, 0.15, 2.0, 0.074]\n\nFor the clairty, we will create a sample plot focusing on the first 4 bars. We adjusted y-range also to have enough room for 3d effects.\n\nfig, ax = plt.subplots(1, 1, num=1, clear=True, figsize=(4, 2.5), layout=\"constrained\")\n\nx = np.arange(len(abcd))\nax.bar(x, freq)\nax.set_xticks(x, abcd)\nax.set_ylabel(\"Frequency [%]\")\nax.set_xlim(-0.6, 3.6)\nax.set_ylim(-1.5, 10)\n\n\n\n\n\n\nmpl-poormasn-3d provide a way to convert your bars to 3d. We will first try BarToPrism class. You create it by setting the lightsource and number of vertices of the shape. Its instance is callable object and can be used as a patheffect. The lightsource should be an instance of matplotlib.colors.LightSource.\n\nfrom matplotlib.colors import LightSource\nfrom mpl_poormans_3d import BarToPrism\n\nlightsource = LightSource(azdeg=25+90)\n\np = ax.patches[0]\n\nnumVertices = 4\nbar_to_prism = BarToPrism(lightsource, numVertices)\n\np.set_path_effects([bar_to_prism])\n\n\n\n\n\n\nBarToPrism takes several keyword arguments. ratio is for aspect ratio, i.e., smaller ratio will give you flat shape. The meaning of scale and rotate_deg should be self-explanatory.\n\np = ax.patches[1]\n\nnumVertices = 8\nbar_to_prism = BarToPrism(lightsource, numVertices, ratio=0.2, scale=0.8, rotate_deg=30)\n\np.set_path_effects([bar_to_prism])\n\n\n\n\n\n\nBarToCylinder will creat a cylinder.\n\nfrom mpl_poormans_3d import BarToCylinder\np = ax.patches[2]\n\nbar_to_prism = BarToCylinder(lightsource, ratio=0.4)\n\np.set_path_effects([bar_to_prism])\n\n\n\n\n\n\nBarToCharPrism will creat a 3d-bar using the character path and BarToPathPrism will do the same using an arbitrary path.\n\nfrom mpl_poormans_3d import BarToCharPrism\np = ax.patches[3]\n\nbar_to_prism = BarToCharPrism(lightsource, \"d\")\n\np.set_path_effects([bar_to_prism])\n\n\n\n\n\n\nThe instance of BarToPrism and its siblings have a get_pe_face method which returns a patheffect that only show the face of the prism at a given position. 0 means bottom, 1 means top. Note that an instance of BarToPrism renders multiple paths and cannot be combined with other patheffects. On the other hand, return value of get_pe_face method can be combine with other patheffects, e.g., patheffects from mpl-visual-context.\n\nimport mpl_visual_context.patheffects as pe\n\nbar_to_prism = BarToCharPrism(lightsource, \"d\")\n\np.set_path_effects([\n    bar_to_prism,\n    bar_to_prism.get_pe_face(1) | pe.FillColor(\"w\") | pe.StrokeColor(\"r\")\n])\n\n\n\n\n\n\nWe can further add a simple shadow to the bar.\n\nimport mpl_visual_context.image_effect as ie\n\nblur_effect = pe.ImageEffect(ie.Pad(20) | ie.Fill(\"k\") | ie.GaussianBlur(5))\n\np.set_path_effects([\n    bar_to_prism.get_pe_face(0) | pe.FillColor(\"k\") | blur_effect,\n    bar_to_prism,\n    bar_to_prism.get_pe_face(1) | pe.FillColor(\"w\") | pe.StrokeColor(\"r\")\n])\n\n\n\n\n\n\nNow, let’s create a plot of full character set and show alphabet frequency. We will set the facolor of bars using the te husl color palette.\n\nfig, ax = plt.subplots(1, 1, num=2, clear=True, figsize=(12, 4), layout=\"constrained\")\n\nx = np.arange(len(abcd))\nax.bar(x, freq)\nax.set_xticks(x, abcd)\nax.set_ylabel(\"Frequency [%]\")\n\nimport seaborn as sns\ncc = sns.color_palette(\"husl\", 26)\n\nrs = np.random.RandomState(8)\nidx = rs.choice(len(cc), len(cc), replace=False)\ncc = np.array(cc)[idx]\n\nfor p, fc in zip(ax.patches, cc):\n    p.set_fc(fc)\n\nax.set_ylim(-1.5, 15)\n\n\n\n\n\n\nWe will use BarToCharPrism to represent the alphabet. We will add some shadow and make the top face white.\n\nlightsource = LightSource(azdeg=25+90)\nblur_effect = pe.ImageEffect(ie.Pad(10) | ie.Fill(\"k\") | ie.GaussianBlur(3))\n\nfor p, fc, c in zip(ax.patches, cc, abcd):\n    bar_to_prism = BarToCharPrism(lightsource, c,\n                                  ratio=0.6,\n                                  rotate_deg=10,\n                                  fraction=0.5,\n                                  scale=1.2,\n                                  distance_mode=np.mean)\n\n    p.set_path_effects([#pe.FillOnly(),\n        (bar_to_prism.get_pe_face(0) | pe.FillColor(\"k\") | blur_effect),\n        bar_to_prism,\n        (bar_to_prism.get_pe_face(1) | pe.FillColor(\"w\"))\n    ])\n\n\n\n\n\n\nWe will create another plot, showing frequncy of Hangul characters (Korean characters) We need specify a font with Korean characters. For the example, we will us korean fonts included in the mplfoints package, but any Korean font should work.\nfrom https://story.pxd.co.kr/958, w/o double consonant\n\nhangul_consonant = \"ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎ\"\nhangul_freq = [11.3, 7.3, 8.0, 6.6, 5.6, 4.8, 9.1, 21.4, 8.3, 2.3, 1.6, 2.2, 1.5, 6.8]\n\nfig, ax = plt.subplots(1, 1, num=3, clear=True, figsize=(12, 4), layout=\"constrained\")\n\nfrom mplfonts.conf import FONT_DIR\nfrom pathlib import Path\nfrom matplotlib.font_manager import FontProperties\n\nfname = Path(FONT_DIR) / \"NotoSerifCJKsc-Regular.otf\"\nfp = FontProperties(fname=fname)\n\nx = np.arange(len(hangul_consonant))\nax.bar(x, hangul_freq)\nax.set_xticks(x, hangul_consonant, fontproperties=fp)\nax.set_ylim(-3, 25)\nax.set_ylabel(\"Frequency [%]\")\n\n\n\n\n\n\nWe want the prism to have varuing shades. For that, we will use material palette. We will pick up the palette from the SecretColors package althoug the original palette is from google’s matrial design.\nPrism instances can be created using the semenet_params.\n\nfrom SecretColors import Palette\nimport seaborn as sns\n\nlightsource = LightSource(azdeg=25+90)\n\npalette = Palette(\"material\")\ncnames = list(c for c in palette.colors.keys() if c not in [\"black\", \"white\"])\nrs = np.random.RandomState(8)\ncnames = rs.choice(cnames, len(cnames), replace=False)\n\nblur_effect = pe.ImageEffect(ie.Pad(10) | ie.Fill(\"k\") | ie.GaussianBlur(3))\n\nfor p, cn, c in zip(ax.patches, cnames, hangul_consonant):\n    cc = [palette.get(cn, shade=shade) for shade in np.linspace(20, 90, 50)]\n    segment_params = (ax, 25, cc, None)\n\n    bar_to_prism = BarToCharPrism(lightsource, c,\n                                  ratio=0.6,\n                                  rotate_deg=10,\n                                  fraction=0.5,\n                                  scale=1.4,\n                                  fontprop=fp,\n                                  segment_params=segment_params,\n                                  )\n\n    p.set_path_effects([\n        bar_to_prism.get_pe_face(0) | pe.FillColor(\"k\") | blur_effect,\n        bar_to_prism,\n        bar_to_prism.get_pe_face(1) | pe.FillColor(\"w\"),\n    ])"
  },
  {
    "objectID": "posts/mpl-20240324-upgrade-violin-plots/index.html",
    "href": "posts/mpl-20240324-upgrade-violin-plots/index.html",
    "title": "Upgrade your violinplot with mpl-visual-context",
    "section": "",
    "text": "In this post, I will show how you can upgrade your violinplot with mpl-visual-context and make it fancy.\npip install mpl-visual-context\n\n\nCode\n\"\"\"\n====================\nVioling Chart demonstraing various mpl-visual-context features\n====================\n\n\"\"\"\n\n# import numpy as np\nimport matplotlib.pyplot as plt\nimport mpl_visual_context.patheffects as pe\nimport seaborn\n\nseaborn.set()\n\ntips = seaborn.load_dataset(\"tips\")\n\n# We start from a simple seaborn violin plot\nfig, axs = plt.subplots(2, 2, num=1, clear=True, figsize=(8, 6), layout=\"constrained\")\nfor ax in axs.flat:\n    seaborn.violinplot(x='day', y='tip', data=tips, ax=ax,\n                       hue='day', palette=\"deep\")\n\nax = axs[0, 0]\nax.annotate(\n    \"(a) Original violin plot\",\n    (0, 1),\n    xytext=(5, -5),\n    xycoords=\"axes fraction\",\n    va=\"top\",\n    ha=\"left\",\n    textcoords=\"offset points\",  # size=20,\n)\n\n# (b) w/ Brighter fill color\nax = axs[0, 1]\n# We select violin patches. It seems that collections created by violinplot are\n# version dependent. So your mileage may vary.\ncolls = ax.collections[::]\n\n\nax.annotate(\n    \"(b) Make fill color lighter,\\nand stroke with the (original) fill color\",\n    (0, 1),\n    xytext=(5, -5),\n    xycoords=\"axes fraction\",\n    va=\"top\",\n    ha=\"left\",\n    textcoords=\"offset points\",  # size=20,\n)\n\npe_list = [\n    pe.HLSModify(l=0.8) | pe.FillOnly(),\n    pe.StrokeColorFromFillColor() | pe.StrokeOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n# (c) AlphaGradient\nax = axs[1, 0]\ncolls = ax.collections[::]\n\nax.annotate(\n    \"(c) Fill w/ alpha gradient\",\n    (0, 1),\n    xytext=(5, -5),\n    xycoords=\"axes fraction\",\n    va=\"top\",\n    ha=\"left\",\n    textcoords=\"offset points\",  # size=20,\n)\n\npe_list = [\n    pe.AlphaGradient(\"0.8 &gt; 0.2 &gt; 0.8\"),\n    (pe.StrokeColorFromFillColor() | pe.StrokeOnly()),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n# (4) w/ Light effect\nax = axs[1, 1]\ncolls = ax.collections[::]\n\nax.annotate(\n    \"(d) Light effect and shadow\",\n    (0, 1),\n    xytext=(5, -5),\n    xycoords=\"axes fraction\",\n    va=\"top\",\n    ha=\"left\",\n    textcoords=\"offset points\",  # size=20,\n)\n\nimport mpl_visual_context.image_effect as ie\n\npe_list = [\n    # shadow\n    pe.FillOnly()\n    | pe.ImageEffect(\n        ie.AlphaAxb((0.5, 0))\n        | ie.Pad(10)\n        | ie.Fill(\"k\")\n        | ie.Dilation(3)\n        | ie.Gaussian(4)\n        | ie.Offset(3, -3)\n    ),\n    # light effect\n    pe.HLSModify(l=0.7)\n    | pe.FillOnly()\n    | pe.ImageEffect(ie.LightSource(erosion_size=5, gaussian_size=5)),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\n\nWe will start with a seaborn violinplot example.\n\n\n\nimport matplotlib.pyplot as plt\nimport seaborn\n\nseaborn.set()\n\ntips = seaborn.load_dataset(\"tips\")\n\nfig, ax = plt.subplots(num=1, clear=True, figsize=(4, 3), layout=\"constrained\" )\nseaborn.violinplot(x='day', y='tip', data=tips, ax=ax,\n                   hue='day', palette=\"deep\")\n\n&lt;Axes: xlabel='day', ylabel='tip'&gt;\n\n\n\n\n\nWhile there are other ways to change the fill-colors and edge-colors of the patches, in this example, we will use patheffect. There are pros and cons. The disadvantages would be that it will increase the runtime performance. Advantage would be that it will keep its original color.\n\n\nSimple patheffect with mpl-visual-context: change color\nLet’s start with a simple example\nThe default edge color is black, let’s sync it to that of the facecolor. We will use mpl-visual-context module, which implements composable patheffects, i.e., it implements various patheffects that can do simple thins and the can be pipelined to make complex patheffects.\n\n\n\nimport mpl_visual_context.patheffects as pe\n\ncolls = ax.collections\n\npe_list = [\n    pe.HLSModify(l=0.8) | pe.FillOnly()\n]\n\nfor coll in colls:\n    coll.set_path_effects(pe_list)\n\n\nHLSModify change the color (both fillcolor and edgecolor) in the HLS space. It will set the lightness to 0.8, making the color brighter. And, FillOnly will fill the path without stroking. By pipelining two patheffects with |, we create a new pathe effect that fills the path with a lighter color.\nNote that we iterate over ax.collections, but ax.collections seem to have different artists based on the seaborn version. So, you may need to iterate over a subset of collections.\n\n\n\n\n\nset_path_effects takes a list of patheffects. And the same path is drawn with different patheffects in sequence. So, let’s add another patheffect. The default edgecolor was black, and we will change the edgecolor to the original fillcolor. StrokeColorFromFillColor will set the edgecolor to that of fillcolor and StrokeOnly will simply stroke the path without filling.\n\npe_list = [\n    pe.HLSModify(l=0.8) | pe.FillOnly(),\n    pe.StrokeColorFromFillColor() | pe.StrokeOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nmpl-visual-context` contains various patheffects. Check out https://mpl-visual-context.readthedocs.io/en/latest/api_path_effect.html for the list of available patheffects.\n\n\nImage-based patheffects\nmpl-visual-context also contains image-base patheffects. Note that these effects won’t draw the path in vector format. Instead, it will rasterize the path and apply filters in image plane then the image is drawn on the canvas. Therefore, in most case, these image-base patheffect should be placed at the end of the pipeline.\nLet’s apply some alpha gradient to the fill. AlphaGradient will make an image of the fill color and adjust the alpha channel of the images. For example, ‘0.8 &gt; 0.2 &gt; 0.8’ means alpha horizontal gradient starting from 0.8 on the left, 0.2 at the center and 0.8 at the right.\n\n\npe_list = [\n    pe.AlphaGradient(\"0.8 &gt; 0.4 &gt; 0.8\"),\n    pe.StrokeColorFromFillColor() | pe.StrokeOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nYou can also do vertical gradient. Instead of ‘&gt;’ use ‘^’. For example, ‘0.8 ^ 0’ means alpha of 0.8 at the bottom and 0 at the top. Note that the image is created with extent of the artist.\n\n\npe_list = [\n    pe.AlphaGradient(\"0.8 ^ 0\"),\n    pe.StrokeColorFromFillColor() | pe.StrokeOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nAlphaGradient is a special case of an ImageEffect patheffect. In fact, ImageEffect implements various effects in image plane that can be pipelined (similar to patheffects)\n\nimport mpl_visual_context.image_effect as ie\n\ndrop_shadow = pe.ImageEffect(\n    ie.AlphaAxb((0.3, 0))\n    | ie.Pad(10)\n    | ie.Fill(\"k\")\n    | ie.Dilation(3)\n    | ie.Gaussian(3)\n    | ie.Offset(3, 3)\n)\n\npe_list = [\n    drop_shadow\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nTogether with the fill, it could be\n\npe_list = [\n    drop_shadow,\n    pe.FillOnly(),\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nTo make it more fancy, we can add light effect. It is based on matplotlib.colors.LightSource. https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LightSource.html\n\nlighteffect = (pe.HLSModify(l=0.7)\n               | pe.FillOnly()\n               | pe.ImageEffect(ie.LightSource(erosion_size=5, gaussian_size=5))\n               )\n\npe_list = [\n    lighteffect\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n\n\n\n\n\nCombining lighteffect with dropshadow,\n\npe_list = [\n    drop_shadow,\n    lighteffect\n]\n\nfor x, coll in enumerate(colls):\n    coll.set_path_effects(pe_list)\n\n# plt.show()"
  },
  {
    "objectID": "posts/mpl-20231130-intro_speech_bubble/index.html",
    "href": "posts/mpl-20231130-intro_speech_bubble/index.html",
    "title": "Introducing mpl-speech-bubble",
    "section": "",
    "text": "In this post, I will introduce mpl-speech-bubble package.\nYou can install it by\n\npip install mpl-speech-bubble\n\nAnd the source code can be found at https://github.com/leejjoon/mpl-speech-bubble and documentation at https://mpl-speech-bubble.readthedocs.io/ (documentation is far from complete)\nWith mpl-speech-bubble, you can annotate you Matplotlib plot with speech bubbles, like this\n\nLet’s start with a Matplotlib’s annotate example. Note that we use “wedge” arrow style.\n\n%matplotlib inline\n\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(num=1, clear=True)\n\nxy = (0.2, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nannotate_kwargs = dict(\n    ha=\"center\", va=\"bottom\",\n    size=20,\n    bbox=dict(boxstyle=\"round, pad=0.2\",\n              fc=\"w\", ec=\"k\"),\n    arrowprops=dict(\n        arrowstyle=\"wedge, tail_width=0.5\",\n        fc=\"y\",\n        patchA=None, # by default, annotate set patchA to the bbox.\n    )\n)\n\nt = ax.annotate(\n    text=\"Default\",\n    xy=xy, xycoords='data',\n    xytext=(-0., .9), textcoords=\"offset fontsize\",\n    **annotate_kwargs\n)\n\nax.set_xlim(0, 1)\n\n(0.0, 1.0)\n\n\n\n\n\nmpl-speech-bubble has a function annotate_merged. This fucntion is mostly identical to MPL’s annotate, and at the drawing time, it will merge the bbox patch and the arrow patch. Behind the scence, it uses skia-pathops to merge bezier paths. The properties of merged patch will inherid from the bbox patch.\n\nfrom mpl_speech_bubble import annotate_merged\n\nxy = (0.5, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nt = annotate_merged(\n    ax,\n    text=\"Merged\",\n    xy=xy, xycoords='data',\n    xytext=(-0., .9), textcoords=\"offset fontsize\",\n    **annotate_kwargs\n)\n\n\n\n\nIn addtion, it provides annotate-bubble function. It has slghtly different call signature from annotate, but has an advantage of better handling of things like rotation.\nInstead of xytext and textcoords, you should use loc and dist. The unit of dist is fontsize.\n\nfrom mpl_speech_bubble import annotate_bubble\n\nxy = (0.8, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nt = annotate_bubble(\n    ax,\n    text=\"Bubble\",\n    xy=xy, xycoords='data',\n    loc=\"up\", dist=1.,\n    size=20,\n)\n\n\n\n\n\n\n\nt = annotate_bubble(\n    ax,\n    text=\"Bubble 2\",\n    xy=xy, xycoords='data',\n    loc=\"down\", dist=1.,\n    size=20, rotation=30,\n)\n\n\n\n\n\n\nannotate_bubble is a simple wrapper around AnnotationBubble class. Please take a look at the example here"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JJL’s Matplotlib blog",
    "section": "",
    "text": "The source code for these posts (mostly jupyter notebook files converted to plain python using jupytext) should be available at the github repo below.\nhttps://github.com/leejjoon/jjl-mpl-blog\nIf you have any comments on the content of this site, please use github issues, etc.\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nWaffle plot\n\n\n\n\n\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2025\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nMatplotlib logo in Cyberpunk style\n\n\n\n\n\n\n\nshowcase\n\n\nmpl-skia-pathops\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nFeb 16, 2025\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nCar crash chart: a step-by-step guide\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-pe-fancy-bar\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nNov 7, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nRendering ColorEmoji with Matplotlib\n\n\n\n\n\n\n\n\n\n\n\n\nOct 28, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nRendering SVG with Matplotlib\n\n\n\n\n\n\n\n\n\n\n\n\nOct 27, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nIntroducing mpl-pe-fancy-bar\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-pe-fancy-bar\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nMay 31, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nAlphabet frequency plot\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-poormans-3d\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nMar 25, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nUpgrade your violinplot with mpl-visual-context\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-visual-context\n\n\n\n\n\n\n\n\n\n\n\nMar 24, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nmpl-flags : drawing flags with Matplotlib\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-flags\n\n\n\n\n\n\n\n\n\n\n\nMar 18, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nAssembling Multiple Legends into a single box\n\n\n\n\n\n\n\n\n\n\n\n\nFeb 24, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nChristmas Patterns in Matplotlib\n\n\n\n\n\n\n\ntutorial\n\n\nmpl-visual-context\n\n\npatterns\n\n\n\n\n\n\n\n\n\n\n\nDec 27, 2023\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nIntroducing mpl-speech-bubble\n\n\n\n\n\n\n\n\n\n\n\n\nNov 30, 2023\n\n\nJae-Joon Lee\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "README_admin.html",
    "href": "README_admin.html",
    "title": "JJL's Matplotlib blog",
    "section": "",
    "text": "jupytext –set-formats ipynb,py:percent notebook.ipynb jupytext –sync notebook.py\n\n\nquarto preview . quarto render quarto publish gh-pages # you should be in main branch"
  },
  {
    "objectID": "posts/mpl-20241027-mpl-simple-svg-parser-user-guide/index.html",
    "href": "posts/mpl-20241027-mpl-simple-svg-parser-user-guide/index.html",
    "title": "Rendering SVG with Matplotlib",
    "section": "",
    "text": "A guide to render SVG in your Matplotlib plot as vector format.\nThis tutorial demonstrates how one can include svg in Matplotlib, as vector format (i.e.g, Matplotlib’s paths). While you can rasterize the svg into an image and include them, we will read the svg file and produce matplotlib path objects.\nWe will use (mpl-simple-svg-parser)[https://mpl-simple-svg-parser.readthedocs.io/en/latest/index.html] package. Note that this package is not fully-featured SVG parser. Instead, it uses (cariosvg)[https://cairosvg.org/] and (picosvg)[https://github.com/googlefonts/picosvg] to convert the input svg into a more manageable svg and then read them with the help of (svgpath2mpl)[https://github.com/nvictus/svgpath2mpl]. The package does support gradient in a very ad hoc way. It uses (Skia)[https://skia.org/] to produce gradient image and include them in the matplotlib plot.\nWhile this is not ideal (and not very efficient), this let you render a good fraction of svg wit matlotlib. On the other hand, features like filters are not supported.\nHere is an example of annotating your plot with svg.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\n\nfrom matplotlib.offsetbox import AnnotationBbox\nfrom mpl_simple_svg_parser import SVGMplPathIterator\n\n\n# TIOBE score from https://spectrum.ieee.org/the-top-programming-languages-2023\n\nl = [\n    (\"Python\", 1),\n    (\"Java\", 0.588),\n    (\"C++\", 0.538),\n    (\"C\", 0.4641),\n    (\"JavaScript\", 0.4638),\n    (\"C#\", 0.3973)\n]\n\ndf = pd.DataFrame(l, columns=[\"Language\", \"Score\"])\n\n\nsns.set_color_codes(\"muted\")\nsns.set(font_scale = 1.5)\n\nfig, ax = plt.subplots(num=1, clear=True, layout=\"constrained\")\n\nsns.barplot(x=\"Score\", y=\"Language\", data=df,\n            label=\"Tiobe Score 2023\", color=\"b\",\n            legend=False)\n\nax.yaxis.label.set_visible(False)\nax.set_title(\"TIOBE Score 2023\")\nax.set_xlim(0, 1.13)\n\nylabels = [l.get_text() for l in ax.get_yticklabels()] # save it to use with svg icons later\nbars = ax.containers[0] # list of rectangles for the bars.\n\nfor bar, l in zip(bars, ylabels):\n    ax.annotate(l, xy=(0, 0.5), xycoords=bar, va=\"center\", ha=\"left\",\n               xytext=(10, 0), textcoords=\"offset points\", color=\"w\")\n\nax.tick_params(axis=\"y\",labelleft=False)\n# ax.tick_params(axis=\"x\",direction=\"in\")\n\nax.set_xlim(0, 1.2) # to make a room for svg annotattion.\n\nimport toml\nicons = toml.load(open(\"svg_icons.toml\"))\n\ndef get_da(b, ax, wmax=64, hmax=64):\n    svg_mpl_path_iterator = SVGMplPathIterator(b)\n    da = svg_mpl_path_iterator.get_drawing_area(ax, wmax=wmax, hmax=hmax)\n    return da\n\nfor l, bar in zip(ylabels, bars):\n    da = get_da(icons[l].encode(\"ascii\"), ax, wmax=32, hmax=32)\n    ab = AnnotationBbox(da, (1., 0.5), xycoords=bar, frameon=False,\n                        xybox=(5, 0), boxcoords=\"offset points\",\n                        box_alignment=(0.0, 0.5))\n    ax.add_artist(ab)\n\nplt.show()\n\n\n\n\n\n\n\n\nUsing SVGMplPathIterator from mpl_simple_svg_parser\nLet’s start with a simple example. The base class is SVGMplPathIterator. It reads the svg string, and produces a list of matplotlib’s path object. If you want to render the svg in the axes’ data coordinate, you may simply use the draw method.\n\nimport matplotlib.pyplot as plt\nfrom mpl_simple_svg_parser import SVGMplPathIterator\n\nfig, ax = plt.subplots(num=1, clear=True)\nax.set_aspect(1)\nfn = \"homer-simpson.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read())\nsvg_mpl_path_iterator.draw(ax)\n\n\n\n\nYou can offset and scale it.\n\n# First let's check the viewbox of the svg.\n\nsvg_mpl_path_iterator.viewbox # This is the size defined in the svg file.\n\n[0.0, 0.0, 375.0, 375.0]\n\n\n\nfig, ax = plt.subplots(num=2, clear=True)\nax.set_aspect(1)\nax.plot([0, 1000], [0, 1000])\n\nfn = \"homer-simpson.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read())\nsvg_mpl_path_iterator.draw(ax, xy=(600, 100), scale=0.7)\n\n\n\n\nThe package mpl-simple-svg-parser processes the input svg content using cairosvg to produce simplified svg. There are some caveats of drawing the result with matplotlib. For example, linewidth in Matplotlib cannot be specified in the data coordinate. In the example below, the arms and legs of the robot is too thin because of this issue.\n\nfig, ax = plt.subplots(num=3, clear=True)\nax.set_aspect(1)\nfn = \"android.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read())\nsvg_mpl_path_iterator.draw(ax)\n\n\n\n\nBesides the stroke width issue, the package does not handle clipping.\nTurning on the option “pico=True” can solve some of the issues. With this option, the svg is further processed by picosvg which converts strokes to fills and clips the paths. Running pico has its own caveats though. You may check this (page)[https://leejjoon.github.io/mpl-simple-svg-parser/gallery/] and check the results.\n\nfig, ax = plt.subplots(num=4, clear=True)\nax.set_aspect(1)\nfn = \"android.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read(), pico=True)\nsvg_mpl_path_iterator.draw(ax)\n\n\n\n\nThe package does support gradient. While the result is reasonable, the implementation is quite naive and not efficient. It uses Skia (or Cairo) to produce gradient image, and let the matplotlib’s backends to clip it.\n\nfig, ax = plt.subplots(num=5, clear=True)\nax.set_aspect(1)\nfn = \"python.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read())\nsvg_mpl_path_iterator.draw(ax)\n\n\n\n\nSometimes, the viewbox size in the svg can be incorrect. You can set datalim_mode=‘path’ to ignore the viewbox, and try to let matplotlib guess its extent based on extent of individual patches (this can be incorrect sometime.)\n\nfig, ax = plt.subplots(num=6, clear=True)\nax.set_aspect(1)\nfn = \"tiger.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read(), pico=True)\nsvg_mpl_path_iterator.draw(ax, datalim_mode=\"path\")\n\n\n\n\nAnd we can render Matplotlib logo!\n\nfig, ax = plt.subplots()\nax.set_aspect(1)\nfn = \"matplotlib-original-wordmark.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read(), pico=True)\nsvg_mpl_path_iterator.draw(ax, datalim_mode=\"path\")\n\nax.tick_params(labelleft=False, labelbottom=False)\n\n\n\n\n\n\nDrawingArea\nFor the examples so far, we draw the svg in Matplotlb’s data coordinates. Often, you want your svg rendering results, behaves like text, whose size is set in points, independent of data coordinates.\nInstead of drawing it direcly on the axes, it is recommented to draw it on DrawingArea – derived from OffsetBox – and use AnnotationBbox to place it on the axes similar to annotation.\n\nfrom matplotlib.offsetbox import AnnotationBbox\n\nfig, ax = plt.subplots(num=7, clear=True)\nfn = \"python.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read())\nda = svg_mpl_path_iterator.get_drawing_area(ax, wmax=64)\n\nab = AnnotationBbox(da, (0.5, 0.5), xycoords=\"data\")\nax.add_artist(ab)\n\n&lt;matplotlib.offsetbox.AnnotationBbox at 0x7c7d5a74d960&gt;\n\n\n\n\n\n\n\nAnnotation Example\nLet’s make a barplot and annotate it with svgs.\nWe start with a boxplot\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\n\nfrom matplotlib.offsetbox import AnnotationBbox\nfrom mpl_simple_svg_parser import SVGMplPathIterator\n\n# TIOBE score from https://spectrum.ieee.org/the-top-programming-languages-2023\nl = [\n    (\"Python\", 1),\n    (\"Java\", 0.588),\n    (\"C++\", 0.538),\n    (\"C\", 0.4641),\n    (\"JavaScript\", 0.4638),\n    (\"C#\", 0.3973)\n]\n\ndf = pd.DataFrame(l, columns=[\"Language\", \"Score\"])\n\nsns.set_color_codes(\"muted\")\nsns.set(font_scale = 1.5)\n\nfig, ax = plt.subplots(num=1, clear=True, layout=\"constrained\")\n\nsns.barplot(x=\"Score\", y=\"Language\", data=df,\n            label=\"Tiobe Score 2023\", color=\"b\",\n            legend=False)\n\nax.yaxis.label.set_visible(False)\nax.set_title(\"TIOBE Score 2023\")\n\nylabels = [l.get_text() for l in ax.get_yticklabels()] # save it to use with svg icons later\nbars = ax.containers[0] # list of rectangles for the bars.\n\nfor bar, l in zip(bars, ylabels):\n    ax.annotate(l, xy=(0, 0.5), xycoords=bar, va=\"center\", ha=\"left\",\n               xytext=(10, 0), textcoords=\"offset points\", color=\"w\")\n\nax.tick_params(axis=\"y\",labelleft=False)\n# ax.tick_params(axis=\"x\",direction=\"in\")\n\nax.set_xlim(0, 1.2) # to make a room for svg annotattion.\n\n\n\n\n\n\nWe annotate the plot with svg in drawing_area.\n\n# We will use svg icons downloaded from (devicons)[https://github.com/devicons/devicon]\n\nimport toml\nicons = toml.load(open(\"svg_icons.toml\"))\nicons[\"Python\"]\n\n'&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\"&gt;&lt;linearGradient id=\"python-original-a\" gradientUnits=\"userSpaceOnUse\" x1=\"70.252\" y1=\"1237.476\" x2=\"170.659\" y2=\"1151.089\" gradientTransform=\"matrix(.563 0 0 -.568 -29.215 707.817)\"&gt;&lt;stop offset=\"0\" stop-color=\"#5A9FD4\"/&gt;&lt;stop offset=\"1\" stop-color=\"#306998\"/&gt;&lt;/linearGradient&gt;&lt;linearGradient id=\"python-original-b\" gradientUnits=\"userSpaceOnUse\" x1=\"209.474\" y1=\"1098.811\" x2=\"173.62\" y2=\"1149.537\" gradientTransform=\"matrix(.563 0 0 -.568 -29.215 707.817)\"&gt;&lt;stop offset=\"0\" stop-color=\"#FFD43B\"/&gt;&lt;stop offset=\"1\" stop-color=\"#FFE873\"/&gt;&lt;/linearGradient&gt;&lt;path fill=\"url(#python-original-a)\" d=\"M63.391 1.988c-4.222.02-8.252.379-11.8 1.007-10.45 1.846-12.346 5.71-12.346 12.837v9.411h24.693v3.137H29.977c-7.176 0-13.46 4.313-15.426 12.521-2.268 9.405-2.368 15.275 0 25.096 1.755 7.311 5.947 12.519 13.124 12.519h8.491V67.234c0-8.151 7.051-15.34 15.426-15.34h24.665c6.866 0 12.346-5.654 12.346-12.548V15.833c0-6.693-5.646-11.72-12.346-12.837-4.244-.706-8.645-1.027-12.866-1.008zM50.037 9.557c2.55 0 4.634 2.117 4.634 4.721 0 2.593-2.083 4.69-4.634 4.69-2.56 0-4.633-2.097-4.633-4.69-.001-2.604 2.073-4.721 4.633-4.721z\" transform=\"translate(0 10.26)\"/&gt;&lt;path fill=\"url(#python-original-b)\" d=\"M91.682 28.38v10.966c0 8.5-7.208 15.655-15.426 15.655H51.591c-6.756 0-12.346 5.783-12.346 12.549v23.515c0 6.691 5.818 10.628 12.346 12.547 7.816 2.297 15.312 2.713 24.665 0 6.216-1.801 12.346-5.423 12.346-12.547v-9.412H63.938v-3.138h37.012c7.176 0 9.852-5.005 12.348-12.519 2.578-7.735 2.467-15.174 0-25.096-1.774-7.145-5.161-12.521-12.348-12.521h-9.268zM77.809 87.927c2.561 0 4.634 2.097 4.634 4.692 0 2.602-2.074 4.719-4.634 4.719-2.55 0-4.633-2.117-4.633-4.719 0-2.595 2.083-4.692 4.633-4.692z\" transform=\"translate(0 10.26)\"/&gt;&lt;radialGradient id=\"python-original-c\" cx=\"1825.678\" cy=\"444.45\" r=\"26.743\" gradientTransform=\"matrix(0 -.24 -1.055 0 532.979 557.576)\" gradientUnits=\"userSpaceOnUse\"&gt;&lt;stop offset=\"0\" stop-color=\"#B8B8B8\" stop-opacity=\".498\"/&gt;&lt;stop offset=\"1\" stop-color=\"#7F7F7F\" stop-opacity=\"0\"/&gt;&lt;/radialGradient&gt;&lt;path opacity=\".444\" fill=\"url(#python-original-c)\" d=\"M97.309 119.597c0 3.543-14.816 6.416-33.091 6.416-18.276 0-33.092-2.873-33.092-6.416 0-3.544 14.815-6.417 33.092-6.417 18.275 0 33.091 2.872 33.091 6.417z\"/&gt;&lt;/svg&gt;\\n'\n\n\n\ndef get_da(b, ax, wmax=64, hmax=64):\n    svg_mpl_path_iterator = SVGMplPathIterator(b)\n    da = svg_mpl_path_iterator.get_drawing_area(ax, wmax=wmax, hmax=hmax)\n    return da\n\nfor l, bar in zip(ylabels, ax.containers[0]):\n\n    da = get_da(icons[l].encode(\"ascii\"), ax, wmax=32, hmax=32)\n    ab = AnnotationBbox(da, (1., 0.5), xycoords=bar, frameon=False,\n                        xybox=(5, 0), boxcoords=\"offset points\",\n                        box_alignment=(0.0, 0.5))\n    ax.add_artist(ab)\n\n\n\n\n\n\n\n\nAccessing the parsed results\nOnce can access the parsed results. The base methods would be ‘iter_path_attrib’ and ‘iter_mpl_path_patch_prop’.\n\nfn = \"python.svg\"\nsvg_mpl_path_iterator = SVGMplPathIterator(open(fn, \"rb\").read())\n\n\nlist(svg_mpl_path_iterator.iter_path_attrib())\n\n[('M 20.25 12 C 20.25 6.75 27 2.25 38.25 2.25 C 49.5 2.25 55.5 6.75 55.5 12 L 55.5 28.5 C 55.5 33.75 51.75 37.5 47.25 37.5 L 29.25 37.5 C 23.25 37.5 18.75 42 18.75 48.75 L 18.75 56.25 L 12 56.25 C 6 56.25 2.25 49.5 2.25 38.25 C 2.25 27.75 6 21 12 21 L 38.25 21 L 38.25 18.75 L 20.25 18.75 Z M 66 37.5 L 66 38.25 ',\n  {'id': 'surface106',\n   'style': ' stroke:none;fill-rule:nonzero;fill:url(#linear0);',\n   'd': 'M 20.25 12 C 20.25 6.75 27 2.25 38.25 2.25 C 49.5 2.25 55.5 6.75 55.5 12 L 55.5 28.5 C 55.5 33.75 51.75 37.5 47.25 37.5 L 29.25 37.5 C 23.25 37.5 18.75 42 18.75 48.75 L 18.75 56.25 L 12 56.25 C 6 56.25 2.25 49.5 2.25 38.25 C 2.25 27.75 6 21 12 21 L 38.25 21 L 38.25 18.75 L 20.25 18.75 Z M 66 37.5 L 66 38.25 '}),\n ('M 55.5 65.25 C 55.5 70.5 49.5 75 38.25 75 C 27 75 20.25 70.5 20.25 65.25 L 20.25 48.75 C 20.25 43.5 24.75 39.75 29.25 39.75 L 47.25 39.75 C 53.25 39.75 57.75 34.5 57.75 28.5 L 57.75 21 L 64.5 21 C 69.75 21 74.25 27.75 74.25 38.25 C 74.25 49.5 69.75 56.25 64.5 56.25 L 38.25 56.25 L 38.25 58.5 L 55.5 58.5 Z M 105 37.5 L 105 38.25 ',\n  {'id': 'surface106',\n   'style': ' stroke:none;fill-rule:nonzero;fill:url(#linear1);',\n   'd': 'M 55.5 65.25 C 55.5 70.5 49.5 75 38.25 75 C 27 75 20.25 70.5 20.25 65.25 L 20.25 48.75 C 20.25 43.5 24.75 39.75 29.25 39.75 L 47.25 39.75 C 53.25 39.75 57.75 34.5 57.75 28.5 L 57.75 21 L 64.5 21 C 69.75 21 74.25 27.75 74.25 38.25 C 74.25 49.5 69.75 56.25 64.5 56.25 L 38.25 56.25 L 38.25 58.5 L 55.5 58.5 Z M 105 37.5 L 105 38.25 '}),\n ('M 51 66 C 51 70 45 70 45 66 C 45 62 51 62 51 66 Z M 51 66 ',\n  {'id': 'surface106',\n   'style': ' stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;',\n   'd': 'M 51 66 C 51 70 45 70 45 66 C 45 62 51 62 51 66 Z M 51 66 '}),\n ('M 30.75 11.25 C 30.75 15.25 24.75 15.25 24.75 11.25 C 24.75 7.25 30.75 7.25 30.75 11.25 Z M 30.75 11.25 ',\n  {'id': 'surface106',\n   'style': ' stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;',\n   'd': 'M 30.75 11.25 C 30.75 15.25 24.75 15.25 24.75 11.25 C 24.75 7.25 30.75 7.25 30.75 11.25 Z M 30.75 11.25 '})]\n\n\n\nlist(svg_mpl_path_iterator.iter_mpl_path_patch_prop())\n\n[(Path(array([[20.25, 63.  ],\n         [20.25, 68.25],\n         [27.  , 72.75],\n         [38.25, 72.75],\n         [49.5 , 72.75],\n         [55.5 , 68.25],\n         [55.5 , 63.  ],\n         [55.5 , 46.5 ],\n         [55.5 , 41.25],\n         [51.75, 37.5 ],\n         [47.25, 37.5 ],\n         [29.25, 37.5 ],\n         [23.25, 37.5 ],\n         [18.75, 33.  ],\n         [18.75, 26.25],\n         [18.75, 18.75],\n         [12.  , 18.75],\n         [ 6.  , 18.75],\n         [ 2.25, 25.5 ],\n         [ 2.25, 36.75],\n         [ 2.25, 47.25],\n         [ 6.  , 54.  ],\n         [12.  , 54.  ],\n         [38.25, 54.  ],\n         [38.25, 56.25],\n         [20.25, 56.25],\n         [20.25, 63.  ],\n         [20.25, 63.  ],\n         [66.  , 37.5 ],\n         [66.  , 36.75]]), array([ 1,  4,  4,  4,  4,  4,  4,  2,  4,  4,  4,  2,  4,  4,  4,  2,  2,\n          4,  4,  4,  4,  4,  4,  2,  2,  2,  2, 79,  1,  2], dtype=uint8)),\n  {'fc': 'none',\n   'ec': 'none',\n   'lw': 1.0,\n   'alpha': 1,\n   'fc_orig': 'url(#linear0)'}),\n (Path(array([[ 55.5 ,   9.75],\n         [ 55.5 ,   4.5 ],\n         [ 49.5 ,   0.  ],\n         [ 38.25,   0.  ],\n         [ 27.  ,   0.  ],\n         [ 20.25,   4.5 ],\n         [ 20.25,   9.75],\n         [ 20.25,  26.25],\n         [ 20.25,  31.5 ],\n         [ 24.75,  35.25],\n         [ 29.25,  35.25],\n         [ 47.25,  35.25],\n         [ 53.25,  35.25],\n         [ 57.75,  40.5 ],\n         [ 57.75,  46.5 ],\n         [ 57.75,  54.  ],\n         [ 64.5 ,  54.  ],\n         [ 69.75,  54.  ],\n         [ 74.25,  47.25],\n         [ 74.25,  36.75],\n         [ 74.25,  25.5 ],\n         [ 69.75,  18.75],\n         [ 64.5 ,  18.75],\n         [ 38.25,  18.75],\n         [ 38.25,  16.5 ],\n         [ 55.5 ,  16.5 ],\n         [ 55.5 ,   9.75],\n         [ 55.5 ,   9.75],\n         [105.  ,  37.5 ],\n         [105.  ,  36.75]]), array([ 1,  4,  4,  4,  4,  4,  4,  2,  4,  4,  4,  2,  4,  4,  4,  2,  2,\n          4,  4,  4,  4,  4,  4,  2,  2,  2,  2, 79,  1,  2], dtype=uint8)),\n  {'fc': 'none',\n   'ec': 'none',\n   'lw': 1.0,\n   'alpha': 1,\n   'fc_orig': 'url(#linear1)'}),\n (Path(array([[51.,  9.],\n         [51.,  5.],\n         [45.,  5.],\n         [45.,  9.],\n         [45., 13.],\n         [51., 13.],\n         [51.,  9.],\n         [51.,  9.],\n         [51.,  9.]]), array([ 1,  4,  4,  4,  4,  4,  4, 79,  1], dtype=uint8)),\n  {'fc': array([1., 1., 1.]),\n   'ec': 'none',\n   'lw': 1.0,\n   'alpha': 1.0,\n   'fc_orig': None}),\n (Path(array([[30.75, 63.75],\n         [30.75, 59.75],\n         [24.75, 59.75],\n         [24.75, 63.75],\n         [24.75, 67.75],\n         [30.75, 67.75],\n         [30.75, 63.75],\n         [30.75, 63.75],\n         [30.75, 63.75]]), array([ 1,  4,  4,  4,  4,  4,  4, 79,  1], dtype=uint8)),\n  {'fc': array([1., 1., 1.]),\n   'ec': 'none',\n   'lw': 1.0,\n   'alpha': 1.0,\n   'fc_orig': None})]"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "PatternMonster provide a greate collection of patterns in svg format. mpl-pe-pattern-monster is a package that lets you use these patterns in matplotlib. The original svg files are converted to matplotlib path definitions and included as a numpy array.\nThis tutorial will provide a simple example of barchart with christmas-related patterns.\nWe start from a simple barchart Adopted from https://matplotlib.org/stable/gallery/lines_bars_and_markers/barchart.html\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nspecies = (\"Adelie\", \"Chinstrap\", \"Gentoo\")\npenguin_means = {\n    'Bill Depth': (18.35, 18.43, 14.98),\n    'Bill Length': (38.79, 48.83, 47.50),\n}\n\nx = np.arange(len(species))  # the label locations\ntotal_width = 0.7  # total width of the group\ndw = 0.2 # fraction of space between bars in the same group\nwidth = total_width / (len(penguin_means) + dw * (len(penguin_means) - 1))\n\nfig, ax = plt.subplots(num=1, clear=True, figsize=(8, 6))\n\nfor i, (attribute, measurement) in enumerate(penguin_means.items()):\n    offset = width * (1 + dw) * i\n    rects = ax.bar(x - 0.5 * total_width + offset, measurement, width,\n                   label=attribute, align=\"edge\")\n    ax.bar_label(rects, padding=3)\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel('Length (mm)')\nax.set_title('Penguin attributes by species')\nax.set_xticks(x, species)\nax.set_ylim(0, 58)\n\n''\n\n\n\n\n\n\n\n\n# First, you need to know the names of the patterns you are going to use.\n# The python package itself does not provide a good way to browse the patterns.\n# You can list the names of patterns by\npm.names[:10]  # We only show the first 10 items.\n\n['waves-1',\n 'waves-2',\n 'waves-3',\n 'waves-4',\n 'waves-5',\n 'waves-6',\n 'waves-7',\n 'chevron-1',\n 'chevron-2',\n 'chevron-3']\n\n\n\n# names are categorized by roots and tags\npm.roots # outputs are suppressed\npm.tags  # outputs are suppressed\n\n\n\n\n\n\n\n\nThe python package only contains path definition, not colors. And you need to provide suitable colors for your pattern.\nIf color_cycle is not specified, the default color cycle of [“C0”, “C1”, …] will be used.\nIf the given color_cycle contains None, it will be interpreted as the facecolor of the parent artist.\nNote that patterns of pattern_monster are rendered using the custom patheffects. If you are not familiar with patheffect, take a look at patheffects-guide\nThe code below uses mpl-visual-context, but I won’t go into details for its use for now.\n\n\n# pattern names, colors and scale factor. Note that all the pattern names in the python package is in lower-case.\n# The colors also from pattern.monster's pallette, that I think go well with the christmas.\n\npatterns = [(\"christmas-tree-1\",\n             [\"#009688\", \"#E91E63\", \"#03A9F4\", \"#ECC94B\"],\n             1),\n            (\"christmas-pattern-2\",\n             [\"#F6AD55\", \"#E91E63\", \"#03A9F4\"],\n             1.5)]\n\nfor bars, slug_colors_scale in zip(ax.containers, patterns):\n\n    slug, colors, scale = slug_colors_scale\n    pattern = pm.get(slug, scale=scale)  # we get the pattern instance using its name, a scale factor.\n    pattern_fill = pattern.fill(ax, color_cycle=colors, alpha=0.5)\n    # its 'fill' method with return patheffect instance.\n\n    path_effects = [\n        pe.FillColor(colors[0]) | pe.GCModify(alpha=0.3),  # Change the fill color and set alpha to 0.3\n        pe.StrokeColor(colors[0]) | pe.GCModify(linewidth=2, alpha=0.5) | pe.StrokeOnly(),\n        # Change the stroke color, set linewidth and alpha, and only stroke (no fill)\n        pattern_fill  # now fill the bar with patterns.\n    ]\n\n    for patch in bars:\n        patch.set_path_effects(path_effects)\n\nax.legend(loc='upper left', ncols=1,\n          handleheight=3., handlelength=3.)"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-we-add-christmas-patterns-from-pattern.monster.",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-we-add-christmas-patterns-from-pattern.monster.",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "# First, you need to know the names of the patterns you are going to use.\n# The python package itself does not provide a good way to browse the patterns.\n# You can list the names of patterns by\npm.names[:10]  # We only show the first 10 items.\n\n['waves-1',\n 'waves-2',\n 'waves-3',\n 'waves-4',\n 'waves-5',\n 'waves-6',\n 'waves-7',\n 'chevron-1',\n 'chevron-2',\n 'chevron-3']\n\n\n\n# names are categorized by roots and tags\npm.roots # outputs are suppressed\npm.tags  # outputs are suppressed"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-lets-apply-the-patterns",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-lets-apply-the-patterns",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "The python package only contains path definition, not colors. And you need to provide suitable colors for your pattern.\nIf color_cycle is not specified, the default color cycle of [“C0”, “C1”, …] will be used.\nIf the given color_cycle contains None, it will be interpreted as the facecolor of the parent artist.\nNote that patterns of pattern_monster are rendered using the custom patheffects. If you are not familiar with patheffect, take a look at patheffects-guide\nThe code below uses mpl-visual-context, but I won’t go into details for its use for now.\n\n\n# pattern names, colors and scale factor. Note that all the pattern names in the python package is in lower-case.\n# The colors also from pattern.monster's pallette, that I think go well with the christmas.\n\npatterns = [(\"christmas-tree-1\",\n             [\"#009688\", \"#E91E63\", \"#03A9F4\", \"#ECC94B\"],\n             1),\n            (\"christmas-pattern-2\",\n             [\"#F6AD55\", \"#E91E63\", \"#03A9F4\"],\n             1.5)]\n\nfor bars, slug_colors_scale in zip(ax.containers, patterns):\n\n    slug, colors, scale = slug_colors_scale\n    pattern = pm.get(slug, scale=scale)  # we get the pattern instance using its name, a scale factor.\n    pattern_fill = pattern.fill(ax, color_cycle=colors, alpha=0.5)\n    # its 'fill' method with return patheffect instance.\n\n    path_effects = [\n        pe.FillColor(colors[0]) | pe.GCModify(alpha=0.3),  # Change the fill color and set alpha to 0.3\n        pe.StrokeColor(colors[0]) | pe.GCModify(linewidth=2, alpha=0.5) | pe.StrokeOnly(),\n        # Change the stroke color, set linewidth and alpha, and only stroke (no fill)\n        pattern_fill  # now fill the bar with patterns.\n    ]\n\n    for patch in bars:\n        patch.set_path_effects(path_effects)\n\nax.legend(loc='upper left', ncols=1,\n          handleheight=3., handlelength=3.)"
  },
  {
    "objectID": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html",
    "href": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html",
    "title": "Matplotlib logo in Cyberpunk style",
    "section": "",
    "text": "In this post, we will recreate the matplotlib logo in Cyberpunk style.\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom matplotlib_logo import make_logo\n\nimport mplcyberpunk\nfrom mpl_skia_pathops import PathOpsPathEffect\n\nimport mpl_visual_context.patheffects as pe\nimport mpl_visual_context.image_box as ib\nimport mpl_visual_context.image_effect as ie\n\nlinewidth_scale = 1.5\n\nwith plt.rc_context():\n    plt.style.use(\"cyberpunk\")\n    fig, ax = make_logo(height_px=int(110 * linewidth_scale),\n                        lw_bars=0.7*linewidth_scale, lw_grid=0.5*linewidth_scale,\n                        lw_border=1*linewidth_scale,\n                        rgrid=[1, 3, 5, 7], with_text=True)\n\n    cmap = plt.get_cmap()  # we canche the default cmap of the cyberpunk theme.\n\nfig.patch.set(alpha=1) # The figure patch was set to transparent.\nax.patch.set_alpha(0.3)\n\ntp = fig.axes[0].patches[0]  # The textpath\ntp.set_clip_on(False)\n\n# make_logo add a circle (rectangle in polar coordinate) patch, that is larger than\n# the axes patch (which is a circle). We will use this circle patch to clip the text.\n\ncircle = sorted(ax.patches, key=lambda a: a.get_zorder())[0]\ncircle.set_visible(False)\n\nunion_circle = PathOpsPathEffect.union(circle)\n# a path effect that unions the given path with the cricle.\n\ntp.set_path_effects([union_circle])\n\n# glow effect\nglow = pe.ImageEffect(ie.Pad(20*linewidth_scale)\n                      | ie.GaussianBlur(10, channel_slice=slice(3, 4))\n                      | ie.AlphaAxb((2, 0))\n                      | ie.Erosion(50*linewidth_scale, channel_slice=slice(0, 3))\n                      )\n\n# We will create an imagebox with the colormap of the cyberpunk theme. We need\n# to increase the extent so that the image is large enough when we stroke it.\ncolor_gradient_box = ib.ImageBox(\"right\", extent=[-0.1, -0.1, 1.1, 1.1],\n                                 coords=tp, axes=ax, cmap=cmap)\n\nstroke_color_gradient = (\n    union_circle\n    | pe.GCModify(linewidth=3*linewidth_scale, alpha=1)\n    | PathOpsPathEffect.stroke2fill()\n    | pe.FillImage(color_gradient_box)\n)\n\ntp.set_path_effects([\n    stroke_color_gradient | glow,\n    union_circle | pe.FillImage(color_gradient_box, alpha=0.5),\n    stroke_color_gradient\n])\n\n\n\n\n\n\n\nWe start with a matplotlib logo. This is adopted from https://matplotlib.org/stable/gallery/misc/logos2.html.\n\nimport matplotlib.pyplot as plt\nfrom matplotlib_logo import make_logo\n\nfig, ax = make_logo(height_px=int(110),\n                    lw_bars=0.7, lw_grid=0.5,\n                    lw_border=1,\n                    rgrid=[1, 3, 5, 7], with_text=True)\n\n\n\n\n\n\n\n\n\nWe will redraw the logo in cybepunk style (using the cyberpunk package). We will also tweak some aspect of the result.\n\nlinewidth_scale = 1.5\n\nwith plt.rc_context():\n    plt.style.use(\"cyberpunk\")\n    fig, ax = make_logo(height_px=int(110 * linewidth_scale),\n                        lw_bars=0.7*linewidth_scale, lw_grid=0.5*linewidth_scale,\n                        lw_border=1*linewidth_scale,\n                        rgrid=[1, 3, 5, 7], with_text=True)\n\n    cmap = plt.get_cmap()  # we canche the default cmap of the cyberpunk theme.\n\nfig.patch.set(alpha=1) # The figure patch was set to transparent.\nax.patch.set_alpha(0.3)\n\ntp = fig.axes[0].patches[0]  # The textpath\ntp.set_clip_on(False)\n\n# make_logo add a circle (rectangle in polar coordinate) patch, that is larger than\n# the axes patch (which is a circle). We will use this circle patch to clip the text.\n\ncircle = sorted(ax.patches, key=lambda a: a.get_zorder())[0]\ncircle.set_visible(False)\n\n\n\n\n\n\n\n\n\nWe’d like to merge the text path and the background circular path of the icon. We use mpl_skia_pathops. This example is based on 0.3.0 version. .\n\nfrom mpl_skia_pathops import PathOpsPathEffect\n\nunion_circle = PathOpsPathEffect.union(circle)\n# a path effect that unions the given path with the cricle.\n\ntp.set_path_effects([union_circle])\n\n\n\n\n\n\n\n\n\nWe will make it more cyberpunk. The effect is adopted from cyberpunk example in the mpl-visual-context package.\n\nimport mpl_visual_context.patheffects as pe\nimport mpl_visual_context.image_box as ib\nimport mpl_visual_context.image_effect as ie\n\n# glow effect\nglow = pe.ImageEffect(ie.Pad(20*linewidth_scale)\n                      | ie.GaussianBlur(10, channel_slice=slice(3, 4))\n                      | ie.AlphaAxb((2, 0))\n                      | ie.Erosion(50*linewidth_scale, channel_slice=slice(0, 3))\n                      )\n\n# We will create an imagebox with the colormap of the cyberpunk theme. We need\n# to increase the extent so that the image is large enough when we stroke it.\ncolor_gradient_box = ib.ImageBox(\"right\", extent=[-0.1, -0.1, 1.1, 1.1],\n                                 coords=tp, axes=ax, cmap=cmap)\n\nstroke_color_gradient = (\n    union_circle\n    | pe.GCModify(linewidth=3*linewidth_scale, alpha=1)\n    | PathOpsPathEffect.stroke2fill()\n    | pe.FillImage(color_gradient_box)\n)\n\ntp.set_path_effects([\n    stroke_color_gradient | glow,\n    union_circle | pe.FillImage(color_gradient_box, alpha=0.5),\n    stroke_color_gradient\n])"
  },
  {
    "objectID": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html#matplotlib-logo",
    "href": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html#matplotlib-logo",
    "title": "Matplotlib logo in Cyberpunk style",
    "section": "",
    "text": "We start with a matplotlib logo. This is adopted from https://matplotlib.org/stable/gallery/misc/logos2.html.\n\nimport matplotlib.pyplot as plt\nfrom matplotlib_logo import make_logo\n\nfig, ax = make_logo(height_px=int(110),\n                    lw_bars=0.7, lw_grid=0.5,\n                    lw_border=1,\n                    rgrid=[1, 3, 5, 7], with_text=True)"
  },
  {
    "objectID": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html#cybepunk-style",
    "href": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html#cybepunk-style",
    "title": "Matplotlib logo in Cyberpunk style",
    "section": "",
    "text": "We will redraw the logo in cybepunk style (using the cyberpunk package). We will also tweak some aspect of the result.\n\nlinewidth_scale = 1.5\n\nwith plt.rc_context():\n    plt.style.use(\"cyberpunk\")\n    fig, ax = make_logo(height_px=int(110 * linewidth_scale),\n                        lw_bars=0.7*linewidth_scale, lw_grid=0.5*linewidth_scale,\n                        lw_border=1*linewidth_scale,\n                        rgrid=[1, 3, 5, 7], with_text=True)\n\n    cmap = plt.get_cmap()  # we canche the default cmap of the cyberpunk theme.\n\nfig.patch.set(alpha=1) # The figure patch was set to transparent.\nax.patch.set_alpha(0.3)\n\ntp = fig.axes[0].patches[0]  # The textpath\ntp.set_clip_on(False)\n\n# make_logo add a circle (rectangle in polar coordinate) patch, that is larger than\n# the axes patch (which is a circle). We will use this circle patch to clip the text.\n\ncircle = sorted(ax.patches, key=lambda a: a.get_zorder())[0]\ncircle.set_visible(False)"
  },
  {
    "objectID": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html#patheffect-to-draw-the-union-of-two-paths",
    "href": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html#patheffect-to-draw-the-union-of-two-paths",
    "title": "Matplotlib logo in Cyberpunk style",
    "section": "",
    "text": "We’d like to merge the text path and the background circular path of the icon. We use mpl_skia_pathops. This example is based on 0.3.0 version. .\n\nfrom mpl_skia_pathops import PathOpsPathEffect\n\nunion_circle = PathOpsPathEffect.union(circle)\n# a path effect that unions the given path with the cricle.\n\ntp.set_path_effects([union_circle])"
  },
  {
    "objectID": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html#matplotlib-logo-in-cyberpunk-style-1",
    "href": "posts/mpl-20250216_matplotlib_logo_cybepunk_style/index.html#matplotlib-logo-in-cyberpunk-style-1",
    "title": "Matplotlib logo in Cyberpunk style",
    "section": "",
    "text": "We will make it more cyberpunk. The effect is adopted from cyberpunk example in the mpl-visual-context package.\n\nimport mpl_visual_context.patheffects as pe\nimport mpl_visual_context.image_box as ib\nimport mpl_visual_context.image_effect as ie\n\n# glow effect\nglow = pe.ImageEffect(ie.Pad(20*linewidth_scale)\n                      | ie.GaussianBlur(10, channel_slice=slice(3, 4))\n                      | ie.AlphaAxb((2, 0))\n                      | ie.Erosion(50*linewidth_scale, channel_slice=slice(0, 3))\n                      )\n\n# We will create an imagebox with the colormap of the cyberpunk theme. We need\n# to increase the extent so that the image is large enough when we stroke it.\ncolor_gradient_box = ib.ImageBox(\"right\", extent=[-0.1, -0.1, 1.1, 1.1],\n                                 coords=tp, axes=ax, cmap=cmap)\n\nstroke_color_gradient = (\n    union_circle\n    | pe.GCModify(linewidth=3*linewidth_scale, alpha=1)\n    | PathOpsPathEffect.stroke2fill()\n    | pe.FillImage(color_gradient_box)\n)\n\ntp.set_path_effects([\n    stroke_color_gradient | glow,\n    union_circle | pe.FillImage(color_gradient_box, alpha=0.5),\n    stroke_color_gradient\n])"
  },
  {
    "objectID": "posts/mpl-20250305_waffle_plot/index.html",
    "href": "posts/mpl-20250305_waffle_plot/index.html",
    "title": "Waffle plot",
    "section": "",
    "text": "Waffle plot\nLet’s decorate waffle plot with matplotlib image effects.\n\nLet’s start with a simple waffle plot, created using the pywaffle package.\n\nimport matplotlib.pyplot as plt\nfrom pywaffle import Waffle\n\nfig, ax = plt.subplots(1, 1, num=1, clear=True)\n\nax.set_aspect(aspect=\"equal\")\n\nWaffle.make_waffle(\n    ax=ax,\n    rows=5,\n    columns=10,\n    values=[30, 16, 4],\n    title={\"label\": \"Waffle\", \"loc\": \"left\"}\n)\n\n\n\n\n\n\nLet’s apply some imageeffect.\n\nfrom mpl_visual_context.patheffects import ImageEffect\nfrom mpl_visual_context.image_effect import Pad, LightSourceSharp\n\npe_waffle1 = ImageEffect(Pad(10) | LightSourceSharp(dist_max=7, azdeg=215, altdeg=70,\n                                                    fraction=0.97,\n                                                    vert_exag=0.2,\n                                                    ))\n\nfor p in ax.patches:\n    p.set_path_effects([pe_waffle1])\n\n\n\n\n\n\nAnother effect.\n\nfrom mpl_visual_context.image_effect import LightSource\n\npe_waffle2 = ImageEffect(Pad(10) | LightSource(azdeg=215))\n\nfor p in ax.patches:\n    p.set_path_effects([pe_waffle2])"
  },
  {
    "objectID": "posts/mpl-20240318-mpl-flags/index.html",
    "href": "posts/mpl-20240318-mpl-flags/index.html",
    "title": "mpl-flags : drawing flags with Matplotlib",
    "section": "",
    "text": "mpl-flags : drawing flags with Matplotlib\nThis post is to introduce mpl-flags package. To demonstrate the package, we would like to reproduce the plot from this post, only the barchart part.\nHere is what the output will look like.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.offsetbox import (TextArea, DrawingArea, AnnotationBbox, VPacker)\nfrom matplotlib.patches import Circle\nfrom mpl_flags import Flags\n\nimport pandas as pd\nimport io\n\ncsvs = \"\"\"Country,2024 Real GDP % Change,Code\nIndia,6.5,IN\nIndonesia,5,ID\nChina,4.6,CN\nTürkiye,3,TR\nArgentina,2.8,AR\nMexico,2.7,MX\nSaudi Arabia,2.7,SA\nRussia,2.6,RU\nKorea,2.2,KR\nU.S.,2.1,US\nBrazil,1.7,BR\nCanada,1.4,CA\nAustralia,1.2,AU\nFrance,1,FR\nSouth Africa,1,ZA\nJapan,0.9,JP\nItaly,0.7,IT\nUnited Kingdom,0.6,GB\nGermany,0.5,DE\n\"\"\"\n\ndf = pd.read_csv(io.StringIO(csvs))\nfig, ax = plt.subplots(1, 1, num=1, figsize=(7, 10), clear=True,\n                       facecolor=\"gold\")\ncountries = df[\"Country\"]\ngdp_changes = df[\"2024 Real GDP % Change\"]\ncountry_codes = df[\"Code\"]\n\npalette = sns.color_palette(\"crest\", n_colors=len(countries))\npalette.reverse()\n\nsns.barplot(x=gdp_changes, y=countries,\n            hue=countries,\n            palette=palette,\n            width=0.9,\n            ax=ax)\n\n\nfor country, gdp_change, bar in zip(countries, gdp_changes, ax.patches):\n    t1 = TextArea(country, textprops=dict(size=10))\n    t2 = TextArea(f\"{gdp_change}%\", textprops=dict(size=14))\n    tt = VPacker(align=\"left\", children=[t1, t2], sep=2)\n    ab = AnnotationBbox(tt, (1, 0.5), xybox=(5, 0),\n                        frameon=False,\n                        xycoords=bar,\n                        boxcoords=\"offset points\",\n                        box_alignment=(0., 0.5))\n    ax.add_artist(ab)\n\nflags = Flags(\"circle\")\n\nkw = dict(frameon=False,\n          box_alignment=(0.5, 0.5))\n\nfor country, code, bar in zip(countries, country_codes, ax.patches):\n\n    # draw white circular background around the flags\n    da = DrawingArea(20, 20, clip=False)\n    da.add_artist(Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\n    da = flags.get_drawing_area(code, wmax=25)\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\nfrom matplotlib.patches import FancyArrowPatch\n\n\nda = DrawingArea(70, 10, clip=False)\narrow = FancyArrowPatch(posA=(0, 5), posB=(70, 5),\n                        arrowstyle='fancy,tail_width=0.2', connectionstyle='arc3',\n                        mutation_scale=15, ec=\"none\", fc=\"w\")\nda.add_artist(arrow) # Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\nt1 = TextArea(\"2024 Real GDP % Change\", textprops=dict(size=12, color=\"w\"))\ntt = VPacker(align=\"right\", children=[t1, da], sep=2)\n\nab = AnnotationBbox(tt, (0.98, 0.5), xycoords=ax.patches[0],\n                    frameon=False,\n                    box_alignment=(1, 0.5))\nax.add_artist(ab)\n\nfig.subplots_adjust(top=0.95, bottom=0.05)\nfig.set_facecolor(\"gold\")\nax.set_axis_off()\n\nplt.show()\n\n\n\n\n\n\n\nmpl-flags\nmpl-flags is a small packages to draw flags in your matplotlib plots It contains the flag data in vector format readily usable with Matplotlib. The original flags data are from svg format, converted to matplotlib’s Path data using mpl-simple-svg-parser. mpl-flags does not contain the original svg files, only the converted data in numpy format (vertices and codes).\n\nfrom mpl_flags import Flags\n\nflags = Flags(\"noto_waved\") # You initialize the Flags class specifying what kind of flags you like to use.\n                            # `noto_waved` is flags from google's noto emoji fonts.\n\nfig, ax = plt.subplots(figsize=(3, 3))\n\nflags.show_flag(ax, \"KR\")\n\n\n\n\nshow_flag method draws the flag in data coordinate.\nThe flag data is collected from various sources. Currently, it includes flags from\n\nGoogle’s noto color emoji font : https://github.com/googlefonts/noto-emoji\ncircle-flags : https://github.com/HatScripts/circle-flags\nflag-icons : https://github.com/lipis/flag-icons\n\nDifferent sources can render the flags differently. You may compare flags of different sources.\n\nfig = plt.figure(figsize=(8, 4), constrained_layout=False)\nsspec = fig.add_gridspec(1, 1)[0, 0]\ncountry_code = \"KR\"\nFlags.show_flag_kinds(sspec, country_code)\n\n\n\n\nSo, there are 6 flag kinds from 3 sources.\nThe country code is based on 2 letter code.\n\nFlags.print_flags_summary()\n\n[All Codes]\nAC AD AE AF AG AI AL AM AN AO AQ AR AS AT AU AW AX AZ BA BB BD BE BF BG BH\nBI BJ BL BM BN BO BQ BR BS BT BV BW BY BZ CA CC CD CF CG CH CI CK CL CM CN\nCO CP CQ CR CU CV CW CX CY CZ DE DG DJ DK DM DO DZ EA EC EE EG EH ER ES ET\nEU FI FJ FK FM FO FR FX GA GB GD GE GF GG GH GI GL GM GN GP GQ GR GS GT GU\nGW GY HK HM HN HR HT HU IC ID IE IL IM IN IO IQ IR IS IT JE JM JO JP KE KG\nKH KI KM KN KP KR KW KY KZ LA LB LC LI LK LR LS LT LU LV LY MA MC MD ME MF\nMG MH MK ML MM MN MO MP MQ MR MS MT MU MV MW MX MY MZ NA NC NE NF NG NI NL\nNO NP NR NU NZ OM PA PC PE PF PG PH PK PL PM PN PR PS PT PW PY QA RE RO RS\nRU RW SA SB SC SD SE SG SH SI SJ SK SL SM SN SO SR SS ST SU SV SX SY SZ TA\nTC TD TF TG TH TJ TK TL TM TN TO TR TT TV TW TZ UA UG UK UM UN US UY UZ VA\nVC VE VG VI VN VU WF WS XK XX YE YT YU ZA ZM ZW\n\n[Missing Codes]\nnoto_original:  CQ AN PC SU XX UK YU FX\nnoto_waved:  CQ AN PC SU XX UK YU FX\n1x1:  CQ AN AC SU UK YU FX EA TA\n4x3:  CQ AN AC SU UK YU FX EA TA\ncircle:  PC\nsimple:  PC\n\n\nAbove example of Korean flag is relatively simple and are modstly identical among kinds. However, for a bit complicated flags, different kinds show different flags. “circle” and “simple” show simplified flags without much details, best for small size, while other kinds reproduce the original flags.\n\nfig = plt.figure(figsize=(8, 4), constrained_layout=False)\nsspec = fig.add_gridspec(2, 1)[0, 0]\ncountry_code = \"US\"\nFlags.show_flag_kinds(sspec, country_code)\n\nsspec = fig.add_gridspec(2, 1)[1, 0]\ncountry_code = \"VG\"\nFlags.show_flag_kinds(sspec, country_code)\n\n\n\n\nmpl-flags package itself does not provide a mechanism to search for the country from common country name. For that, you may use packages like pycountry.\nIn the above example, we used show_flag method to draw the flag in data coordinate. Often, this is not you want. You want it to behave like texts.\nThus you are recommended to use get_drawing_area method. This returns matplotlib.offsetbox’s DrawingArea instance.\nIf you are not familar with these, you may take a look at this guide\n\nfrom matplotlib.offsetbox import AnnotationBbox\n\nflags = Flags(\"noto_original\")\n\nfig, ax = plt.subplots(figsize=(3, 3))\nda = flags.get_drawing_area(\"KR\", wmax=100)\nab = AnnotationBbox(da, (0.5, 0.5), frameon=True,\n                    box_alignment=(0.5, 0.5))\nax.add_artist(ab)\n\n&lt;matplotlib.offsetbox.AnnotationBbox at 0x7fd5069febf0&gt;\n\n\n\n\n\nNow, let’s see how we can creat the barplots with flags. We will start the demo by loading the data as pandas DataFrame.\n\nimport pandas as pd\nimport io\n\ncsvs = \"\"\"Country,2024 Real GDP % Change,Code\nIndia,6.5,IN\nIndonesia,5,ID\nChina,4.6,CN\nTürkiye,3,TR\nArgentina,2.8,AR\nMexico,2.7,MX\nSaudi Arabia,2.7,SA\nRussia,2.6,RU\nKorea,2.2,KR\nU.S.,2.1,US\nBrazil,1.7,BR\nCanada,1.4,CA\nAustralia,1.2,AU\nFrance,1,FR\nSouth Africa,1,ZA\nJapan,0.9,JP\nItaly,0.7,IT\nUnited Kingdom,0.6,GB\nGermany,0.5,DE\n\"\"\"\n\ndf = pd.read_csv(io.StringIO(csvs))\n\nThen, we will create a bar chart plot, without flags. Note that we are adding texts using AnnotationBbox and providing the bar itself as a coordinate, which means we will use a coordinate that is normalized to the extent of the bar.\n\n# Set up the matplotlib figure\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.offsetbox import (TextArea, DrawingArea, AnnotationBbox, VPacker)\nfrom matplotlib.patches import FancyArrowPatch\n\n\nfig, ax = plt.subplots(1, 1, num=1, figsize=(7, 10), clear=True,\n                       facecolor=\"gold\")\ncountries = df[\"Country\"]\ngdp_changes = df[\"2024 Real GDP % Change\"]\ncountry_codes = df[\"Code\"]\n\npalette = sns.color_palette(\"crest\", n_colors=len(countries))\npalette.reverse()\n\nsns.barplot(x=gdp_changes, y=countries,\n            hue=countries,\n            palette=palette,\n            width=0.9,\n            ax=ax)\n\n# Add text labels of country name and percentage\nfor country, gdp_change, bar in zip(countries, gdp_changes, ax.patches):\n    t1 = TextArea(country, textprops=dict(size=10))\n    t2 = TextArea(f\"{gdp_change}%\", textprops=dict(size=14))\n    tt = VPacker(align=\"left\", children=[t1, t2], sep=2)\n    ab = AnnotationBbox(tt, (1, 0.5), xybox=(5, 0),\n                        frameon=False,\n                        xycoords=bar,\n                        boxcoords=\"offset points\",\n                        box_alignment=(0., 0.5))\n    ax.add_artist(ab)\n\n# For the top bar, we add text explaing the current plot.\nda = DrawingArea(70, 10, clip=False)\narrow = FancyArrowPatch(posA=(0, 5), posB=(70, 5),\n                        arrowstyle='fancy,tail_width=0.2', connectionstyle='arc3',\n                        mutation_scale=15, ec=\"none\", fc=\"w\")\nda.add_artist(arrow) # Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\nt1 = TextArea(\"2024 Real GDP % Change\", textprops=dict(size=12, color=\"w\"))\ntt = VPacker(align=\"right\", children=[t1, da], sep=2)\n\nab = AnnotationBbox(tt, (0.98, 0.5), xycoords=ax.patches[0],\n                    frameon=False,\n                    box_alignment=(1, 0.5))\nax.add_artist(ab)\n\n# adjust subplot parameters and set the backgrond to gold.\nfig.subplots_adjust(top=0.95, bottom=0.05)\nfig.set_facecolor(\"gold\")\nax.set_axis_off()\n\n\n\n\nWe are now going to add flags. If you know how annoatation_box works, adding flags is very straight forward. In the example below, we will create two DrawingArea per bar. The first one is to draw a white background circle for the flags. And another DrawingArea for flags of circle kind.\n\n\nfrom matplotlib.patches import Circle\nfrom mpl_flags import Flags\nflags = Flags(\"circle\")\n\nkw = dict(frameon=False,\n          box_alignment=(0.5, 0.5))\n\nfor country, code, bar in zip(countries, country_codes, ax.patches):\n\n    # draw white circular background around the flags\n    da = DrawingArea(20, 20, clip=False) # since we are using box_aligment=(0.5, 0.5) and clip=Flase,\n                                        # the size of Drawing Area does not realy matter\n    da.add_artist(Circle((10, 10), 15, ec=\"none\", fc=\"w\")) # place the circle at the center of the drawing_area.\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\n    # Now we draw flags.\n    da = flags.get_drawing_area(code, wmax=25)\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\n\n\n\n\n\n\n\nno gradient support\nSome flags (the original svg files) use gradient, which is not currently supported by mpl-flags. Below, we compare original svg file (left) and mpl-flags flag rendering. You will notice what mpl-flags result misses some colors.\n\n# list of flags with gradient\n\nwith_gradients = {\n    \"noto_original\": ['BZ', 'EC', 'FK', 'GS', 'GT', 'MX', 'NI', 'PM', 'TA', 'VG'],\n    \"4x3\": ['BZ', 'FK', 'GS', 'GT', 'MX', 'NI', 'VG']\n}\n\n\nflags = Flags(\"noto_original\")\ncodes = with_gradients[\"noto_original\"]\nget_filename = lambda code: f\"../../../../mpl-flags/third_party/noto-emoji/third_party/region-flags/svg/{code}.svg\"\n\nfig = plt.figure(num=1, figsize=(4, 8))\ncompare_svg(fig, flags, codes, get_filename)\n\n\n\n\n\nflags = Flags(\"4x3\")\ncodes = with_gradients[\"4x3\"]\nget_filename = lambda code: f\"../../../../mpl-flags/third_party/flag-icons/flags/4x3/{code.lower()}.svg\"\n\nfig = plt.figure(num=1, figsize=(4, 6.5))\ncompare_svg(fig, flags, codes, get_filename)"
  },
  {
    "objectID": "posts/mpl-20241028-matplotlib-renders-color-emoji/index.html",
    "href": "posts/mpl-20241028-matplotlib-renders-color-emoji/index.html",
    "title": "Rendering ColorEmoji with Matplotlib",
    "section": "",
    "text": "Using ColorEmoji in Matplotlib\nIn previous post, we introduced mpl-simple-svg-parser package that lets you render svg. You can further use this to render color emoji.\nYou will need a color emoji font with COLR table. For example, Noto Color Emoji can be downaloaded from https://fonts.google.com/noto/specimen/Noto+Color+Emoji\nYou can transform the glyphs in the font to SVG, and uses mpl-simple-svg-parser, for example, to render it with matplotlib.\nmpl-colr2svg is a package that does this. To convert emoji to svg, it uses nanoemoji. Altenatively, it can use blackrenderer to render emoji font to svg.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nemoji_popularity = [[\"😂\", 223.94],\n                    [\"🤣\", 170.29],\n                    [\"❤️\", 95.02],\n                    [\"🙏\", 116.92],\n                    [\"😭\", 95.02],\n                    [\"😍\", 77.3],\n                    [\"✨\", 76.34],\n                    [\"🔥\", 71.52],\n                    [\"😊\", 70.15],\n                    [\"🥰\", 67.35],\n                    ]\n\ndf = pd.DataFrame(emoji_popularity, columns=[\"Emoji\", \"Popularity\"])\n\nimport seaborn as sns\nsns.set_color_codes(\"muted\")\nsns.set(font_scale = 1.5)\n\nfig, ax = plt.subplots(1, 1, figsize=(7, 4), clear=True, num=2, layout=\"constrained\")\n\nsns.barplot(x=\"Emoji\", y=\"Popularity\", data=df,\n            label=\"Emoji Popularity\", color=\"b\")\n\nfrom mpl_colr2svg import ColorEmoji\n\nftname = \"NotoColorEmoji-Regular.ttf\"\nfontsize = 25\n\nemoji = ColorEmoji(ftname)\n\nfor l in ax.get_xticklabels():\n    c = l.get_text()\n    xy = l.get_position()\n\n    l.set_visible(False)\n\n    emoji.annotate(ax, c, xy, xycoords=(\"data\", \"axes fraction\"),\n                   box_alignment=(0.5, 1), fontsize=fontsize,\n                   annotation_clip=True)\n\nax.xaxis.labelpad = fontsize * 1.7\n\nplt.show()\n\n\n\n\n\nLet’s start with a simple example.\n\nimport matplotlib.pyplot as plt\nfrom mpl_colr2svg import ColorEmoji\n\n\nftname = \"NotoColorEmoji-Regular.ttf\"\nemoji = ColorEmoji(ftname)\nc = \"🤩\"\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 5), clear=True, num=1)\nax1 = axs[0]\nax1.set_title(\"draw in data coordinate\")\n\nemoji.draw(ax1, c, size=128)\n\nax2 = axs[1]\n\nemoji.annotate(ax2, c, (0.5, 0.5), fontsize=128)\nax2.set_title(\"drawing_area with annotate\")\n\nplt.show()\n\n\n\n\nYou may use blackrender. The default ColorEmoji only support a sing glyph, but the blackrenderer version supports string of multiple charaters.\n\n\nimport matplotlib.pyplot as plt\nfrom mpl_colr2svg.color_emoji_blackrenderer import ColorEmojiBlackrenderer\n\nftname = \"seguiemj.ttf\"\nemoji = ColorEmojiBlackrenderer(ftname)\ntextString = \"L❤️VE\"\n\nfig, ax = plt.subplots(1, 1, clear=True, num=1)\n\nemoji.annotate(ax, textString, (0.5, 0.5), fontsize=128)\n\nplt.show()\n\n\n\n\n\nHere is a more useful example. We start with a seabron plot of emoji popularity.\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nemoji_popularity = [[\"😂\", 223.94],\n                    [\"🤣\", 170.29],\n                    [\"❤️\", 95.02],\n                    [\"🙏\", 116.92],\n                    [\"😭\", 95.02],\n                    [\"😍\", 77.3],\n                    [\"✨\", 76.34],\n                    [\"🔥\", 71.52],\n                    [\"😊\", 70.15],\n                    [\"🥰\", 67.35],\n                    ]\n\ndf = pd.DataFrame(emoji_popularity, columns=[\"Emoji\", \"Popularity\"])\n\nimport seaborn as sns\nsns.set_color_codes(\"muted\")\nsns.set(font_scale = 1.5)\n\nfig, ax = plt.subplots(1, 1, figsize=(7, 4), clear=True, num=2, layout=\"constrained\")\n\nsns.barplot(x=\"Emoji\", y=\"Popularity\", data=df,\n            label=\"Emoji Popularity\", color=\"b\")\n\n&lt;Axes: xlabel='Emoji', ylabel='Popularity'&gt;\n\n\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/events.py:82: UserWarning: Glyph 129315 (\\N{ROLLING ON THE FLOOR LAUGHING}) missing from font(s) DejaVu Sans.\n  func(*args, **kwargs)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/events.py:82: UserWarning: Glyph 128591 (\\N{PERSON WITH FOLDED HANDS}) missing from font(s) DejaVu Sans.\n  func(*args, **kwargs)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/events.py:82: UserWarning: Glyph 10024 (\\N{SPARKLES}) missing from font(s) DejaVu Sans.\n  func(*args, **kwargs)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/events.py:82: UserWarning: Glyph 128293 (\\N{FIRE}) missing from font(s) DejaVu Sans.\n  func(*args, **kwargs)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/events.py:82: UserWarning: Glyph 129392 (\\N{SMILING FACE WITH SMILING EYES AND THREE HEARTS}) missing from font(s) DejaVu Sans.\n  func(*args, **kwargs)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/pylabtools.py:152: UserWarning: Glyph 129315 (\\N{ROLLING ON THE FLOOR LAUGHING}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/pylabtools.py:152: UserWarning: Glyph 128591 (\\N{PERSON WITH FOLDED HANDS}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/pylabtools.py:152: UserWarning: Glyph 10024 (\\N{SPARKLES}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/pylabtools.py:152: UserWarning: Glyph 128293 (\\N{FIRE}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/jjlee/miniconda3/envs/mpl-dev/lib/python3.10/site-packages/IPython/core/pylabtools.py:152: UserWarning: Glyph 129392 (\\N{SMILING FACE WITH SMILING EYES AND THREE HEARTS}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n\n\n\n\n\nDon’t worry if you see tofus. We will replace the x-tick labels with color emoji.\n\nfrom mpl_colr2svg import ColorEmoji\n\nftname = \"NotoColorEmoji-Regular.ttf\"\nfontsize = 25\n\nemoji = ColorEmoji(ftname)\n\nfor l in ax.get_xticklabels():\n    c = l.get_text()\n    xy = l.get_position()\n\n    l.set_visible(False)\n\n    emoji.annotate(ax, c, xy, xycoords=(\"data\", \"axes fraction\"),\n                   box_alignment=(0.5, 1), fontsize=fontsize,\n                   annotation_clip=True)\n\nax.xaxis.labelpad = fontsize * 1.7"
  }
]