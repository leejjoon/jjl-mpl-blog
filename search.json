[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/mpl-20240224-multiple-legends/index.html",
    "href": "posts/mpl-20240224-multiple-legends/index.html",
    "title": "Assembling Multiple Legends into a single box",
    "section": "",
    "text": "My solution to https://twitter.com/zh1zh4n6/status/1759823358340825149\nA legend is a collection of OffsetBox instances. You may collect multiple legends and rearange them to your need.\n\nimport matplotlib.pyplot as plt\n\n\nExample of multiple legends\nWe will start with a modified version of the multiple legend example from multiple-legends-on-the-same-axes\nNote that multiple calls of ax.legend will replace an exising legend. To work around this, we manually add the legend artist to the axes using ax.add_artist.\n\n#! echo: false\n\ndef plot(ax):\n    line1, = ax.plot([1, 2, 3], label=\"Line 1\", linestyle='--')\n    line2, = ax.plot([3, 2, 1], label=\"Line 2\", linewidth=4)\n\n    sct1 = ax.scatter([0, 1, 2], [1.5, 4, 2.], label=\"Sct 1\", marker=\"s\")\n    sct2 = ax.scatter([0, 1, 2], [4, 3, 0.5], label=\"Sct 2\", marker=\"^\")\n\n    return [line1, line2], [sct1, sct2]\n\ntitle_props = dict(alignment=\"left\",\n                   title_fontproperties=dict(weight=\"bold\"))\n\nfig, ax = plt.subplots(num=1, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Create a legend for the first set.\nfirst_legend = ax.legend(handles=[line1, sct1], loc='upper right',\n                         title=\"Data 1\", **title_props)\n\n# Add the legend manually to the Axes.\nax.add_artist(first_legend)\n\n# Create another legend for the second.\nax.legend(handles=[line2, sct2], loc='lower right',\n          title=\"Data 2\", **title_props)\n\n&lt;matplotlib.legend.Legend at 0x7fe8cdde6170&gt;\n\n\n\n\n\n\n\nAssembling multiple legends\nIn the modified version below, We will create multiple legend boxes, which will be assemebed into a single offset box. Note that we don’t want individual legends be displayed.\n\nfig, ax = plt.subplots(num=2, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Legend is a collection of offset_box instances, wrapped around with\n# AnchoredOffsetbox. We will create legends and collect the offset_box\n# instances, but without showing them on the screen for now.\noffsetboxes = []\nfor title, handles in [(\"Data 1\", [line1, sct1]),\n                       (\"Data 2\", [line2, sct2])]:\n    leg = ax.legend(handles=handles,\n                        title=title, **title_props)\n    offsetboxes.append(leg._legend_box)\n\nax.legend_.remove() # We don't want the legend to be displayed.\n\nWe now have a list of offset-boxes. One can vertically pack boxes into a single box and place it on the corner of the axes, similar to a legend.\n\n# We will add the collected offsetbox. They first need to be packed in a box.\n# We use `VPacker` which will pack its childrent vertically.\nfrom matplotlib.offsetbox import VPacker, AnchoredOffsetbox\nvp = VPacker(children=offsetboxes, sep=15)\n\n# Then this will be added to the axes using `AnchoredOffsetbox`, which can be\n# placed just like legend.\nob = AnchoredOffsetbox(loc=\"upper right\", bbox_to_anchor=ax.bbox, child=vp)\nax.add_artist(ob)\n\n\n\n\n\n\nOf course it is possible to place the box outside the axes. There are several ways to do this. I will use axes_grid1 toolkit, which I am most familiar with.\nWe will start with a sample example.\n\nfig, ax = plt.subplots(num=3, clear=True)\n\n[line1, line2], [sct1, sct2] = plot(ax)\n\n# Legend is a collection of offset_box instances, wrapped around with\n# AnchoredOffsetbox. We will create legends and collect the offset_box\n# instances, but without showing them on the screen for now.\noffsetboxes = []\nfor title, handles in [(\"Data 1\", [line1, sct1]),\n                       (\"Data 2\", [line2, sct2])]:\n    leg = ax.legend(handles=handles,\n                        title=title, **title_props)\n    offsetboxes.append(leg._legend_box)\n\nax.legend_.remove() # We don't want the legend to be displayed.\n\n\n\nPlacing the box outside of the main axes\nWe will create a new axes on the right side of the main axes. In addtion, we want the width of this axes set to the width of the offset box.\n\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.axes_size import MaxWidth\n\nvp = VPacker(children=offsetboxes, sep=15)\n\ndivider = make_axes_locatable(ax)\nartist_list = [] # we start with an empty artist list.\nax_right = divider.append_axes(\"right\", size=MaxWidth(artist_list), pad=0.1)\n\nob = AnchoredOffsetbox(loc=\"upper left\", bbox_to_anchor=ax_right.bbox, child=vp,\n                       pad=0, borderpad=0)\n\nax_right.add_artist(ob)\n\n# We add `ob` to the artist_list, so that the width of `ax_right` is adjusted.\nartist_list.append(ob)\n\nax_right.set_axis_off()"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "PatternMonster provide a greate collection of patterns in svg format. mpl-pe-pattern-monster is a package that lets you use these patterns in matplotlib. The original svg files are converted to matplotlib path definitions and included as a numpy array.\nThis tutorial will provide a simple example of barchart with christmas-related patterns.\nWe start from a simple barchart Adopted from https://matplotlib.org/stable/gallery/lines_bars_and_markers/barchart.html\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nspecies = (\"Adelie\", \"Chinstrap\", \"Gentoo\")\npenguin_means = {\n    'Bill Depth': (18.35, 18.43, 14.98),\n    'Bill Length': (38.79, 48.83, 47.50),\n}\n\nx = np.arange(len(species))  # the label locations\ntotal_width = 0.7  # total width of the group\ndw = 0.2 # fraction of space between bars in the same group\nwidth = total_width / (len(penguin_means) + dw * (len(penguin_means) - 1))\n\nfig, ax = plt.subplots(num=1, clear=True, figsize=(8, 6))\n\nfor i, (attribute, measurement) in enumerate(penguin_means.items()):\n    offset = width * (1 + dw) * i\n    rects = ax.bar(x - 0.5 * total_width + offset, measurement, width,\n                   label=attribute, align=\"edge\")\n    ax.bar_label(rects, padding=3)\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel('Length (mm)')\nax.set_title('Penguin attributes by species')\nax.set_xticks(x, species)\nax.set_ylim(0, 58)\n\n''\n\n\n\n\n\n\n\n\n# First, you need to know the names of the patterns you are going to use.\n# The python package itself does not provide a good way to browse the patterns.\n# You can list the names of patterns by\npm.names[:10]  # We only show the first 10 items.\n\n['waves-1',\n 'waves-2',\n 'waves-3',\n 'waves-4',\n 'waves-5',\n 'waves-6',\n 'waves-7',\n 'chevron-1',\n 'chevron-2',\n 'chevron-3']\n\n\n\n# names are categorized by roots and tags\npm.roots # outputs are suppressed\npm.tags  # outputs are suppressed\n\n\n\n\n\n\n\n\nThe python package only contains path definition, not colors. And you need to provide suitable colors for your pattern.\nIf color_cycle is not specified, the default color cycle of [“C0”, “C1”, …] will be used.\nIf the given color_cycle contains None, it will be interpreted as the facecolor of the parent artist.\nNote that patterns of pattern_monster are rendered using the custom patheffects. If you are not familiar with patheffect, take a look at patheffects-guide\nThe code below uses mpl-visual-context, but I won’t go into details for its use for now.\n\n\n# pattern names, colors and scale factor. Note that all the pattern names in the python package is in lower-case.\n# The colors also from pattern.monster's pallette, that I think go well with the christmas.\n\npatterns = [(\"christmas-tree-1\",\n             [\"#009688\", \"#E91E63\", \"#03A9F4\", \"#ECC94B\"],\n             1),\n            (\"christmas-pattern-2\",\n             [\"#F6AD55\", \"#E91E63\", \"#03A9F4\"],\n             1.5)]\n\nfor bars, slug_colors_scale in zip(ax.containers, patterns):\n\n    slug, colors, scale = slug_colors_scale\n    pattern = pm.get(slug, scale=scale)  # we get the pattern instance using its name, a scale factor.\n    pattern_fill = pattern.fill(ax, color_cycle=colors, alpha=0.5)\n    # its 'fill' method with return patheffect instance.\n\n    path_effects = [\n        pe.FillColor(colors[0]) | pe.GCModify(alpha=0.3),  # Change the fill color and set alpha to 0.3\n        pe.StrokeColor(colors[0]) | pe.GCModify(linewidth=2, alpha=0.5) | pe.StrokeOnly(),\n        # Change the stroke color, set linewidth and alpha, and only stroke (no fill)\n        pattern_fill  # now fill the bar with patterns.\n    ]\n\n    for patch in bars:\n        patch.set_path_effects(path_effects)\n\nax.legend(loc='upper left', ncols=1,\n          handleheight=3., handlelength=3.)"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-we-add-christmas-patterns-from-pattern.monster.",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-we-add-christmas-patterns-from-pattern.monster.",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "# First, you need to know the names of the patterns you are going to use.\n# The python package itself does not provide a good way to browse the patterns.\n# You can list the names of patterns by\npm.names[:10]  # We only show the first 10 items.\n\n['waves-1',\n 'waves-2',\n 'waves-3',\n 'waves-4',\n 'waves-5',\n 'waves-6',\n 'waves-7',\n 'chevron-1',\n 'chevron-2',\n 'chevron-3']\n\n\n\n# names are categorized by roots and tags\npm.roots # outputs are suppressed\npm.tags  # outputs are suppressed"
  },
  {
    "objectID": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-lets-apply-the-patterns",
    "href": "posts/mpl-20231227-christmas_with_pattern_monster/index.html#now-lets-apply-the-patterns",
    "title": "Christmas Patterns in Matplotlib",
    "section": "",
    "text": "The python package only contains path definition, not colors. And you need to provide suitable colors for your pattern.\nIf color_cycle is not specified, the default color cycle of [“C0”, “C1”, …] will be used.\nIf the given color_cycle contains None, it will be interpreted as the facecolor of the parent artist.\nNote that patterns of pattern_monster are rendered using the custom patheffects. If you are not familiar with patheffect, take a look at patheffects-guide\nThe code below uses mpl-visual-context, but I won’t go into details for its use for now.\n\n\n# pattern names, colors and scale factor. Note that all the pattern names in the python package is in lower-case.\n# The colors also from pattern.monster's pallette, that I think go well with the christmas.\n\npatterns = [(\"christmas-tree-1\",\n             [\"#009688\", \"#E91E63\", \"#03A9F4\", \"#ECC94B\"],\n             1),\n            (\"christmas-pattern-2\",\n             [\"#F6AD55\", \"#E91E63\", \"#03A9F4\"],\n             1.5)]\n\nfor bars, slug_colors_scale in zip(ax.containers, patterns):\n\n    slug, colors, scale = slug_colors_scale\n    pattern = pm.get(slug, scale=scale)  # we get the pattern instance using its name, a scale factor.\n    pattern_fill = pattern.fill(ax, color_cycle=colors, alpha=0.5)\n    # its 'fill' method with return patheffect instance.\n\n    path_effects = [\n        pe.FillColor(colors[0]) | pe.GCModify(alpha=0.3),  # Change the fill color and set alpha to 0.3\n        pe.StrokeColor(colors[0]) | pe.GCModify(linewidth=2, alpha=0.5) | pe.StrokeOnly(),\n        # Change the stroke color, set linewidth and alpha, and only stroke (no fill)\n        pattern_fill  # now fill the bar with patterns.\n    ]\n\n    for patch in bars:\n        patch.set_path_effects(path_effects)\n\nax.legend(loc='upper left', ncols=1,\n          handleheight=3., handlelength=3.)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JJL’s Matplotlib blog",
    "section": "",
    "text": "The source code for these posts (mostly jupyter notebook files converted to plain python using jupytext) should be available at the github repo below.\nhttps://github.com/leejjoon/jjl-mpl-blog\nIf you have any comments on the content of this site, please use github issues, etc.\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nmpl-flags : drawing flags with Matplotlib\n\n\n\n\n\n\n\n\n\n\n\n\nMar 18, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nAssembling Multiple Legends into a single box\n\n\n\n\n\n\n\n\n\n\n\n\nFeb 24, 2024\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nChristmas Patterns in Matplotlib\n\n\n\n\n\n\n\n\n\n\n\n\nDec 27, 2023\n\n\nJae-Joon Lee\n\n\n\n\n\n\n  \n\n\n\n\nIntroducing mpl-speech-bubble\n\n\n\n\n\n\n\n\n\n\n\n\nNov 30, 2023\n\n\nJae-Joon Lee\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "README_admin.html",
    "href": "README_admin.html",
    "title": "JJL's Matplotlib blog",
    "section": "",
    "text": "jupytext –set-formats ipynb,py:percent notebook.ipynb jupytext –sync notebook.py\n\n\nquarto preview . quarto render quarto publish gh-pages # you should be in main branch"
  },
  {
    "objectID": "posts/mpl-20231130-intro_speech_bubble/index.html",
    "href": "posts/mpl-20231130-intro_speech_bubble/index.html",
    "title": "Introducing mpl-speech-bubble",
    "section": "",
    "text": "In this post, I will introduce mpl-speech-bubble package.\nYou can install it by\n\npip install mpl-speech-bubble\n\nAnd the source code can be found at https://github.com/leejjoon/mpl-speech-bubble and documentation at https://mpl-speech-bubble.readthedocs.io/ (documentation is far from complete)\nWith mpl-speech-bubble, you can annotate you Matplotlib plot with speech bubbles, like this\n\nLet’s start with a Matplotlib’s annotate example. Note that we use “wedge” arrow style.\n\n%matplotlib inline\n\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(num=1, clear=True)\n\nxy = (0.2, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nannotate_kwargs = dict(\n    ha=\"center\", va=\"bottom\",\n    size=20,\n    bbox=dict(boxstyle=\"round, pad=0.2\",\n              fc=\"w\", ec=\"k\"),\n    arrowprops=dict(\n        arrowstyle=\"wedge, tail_width=0.5\",\n        fc=\"y\",\n        patchA=None, # by default, annotate set patchA to the bbox.\n    )\n)\n\nt = ax.annotate(\n    text=\"Default\",\n    xy=xy, xycoords='data',\n    xytext=(-0., .9), textcoords=\"offset fontsize\",\n    **annotate_kwargs\n)\n\nax.set_xlim(0, 1)\n\n(0.0, 1.0)\n\n\n\n\n\nmpl-speech-bubble has a function annotate_merged. This fucntion is mostly identical to MPL’s annotate, and at the drawing time, it will merge the bbox patch and the arrow patch. Behind the scence, it uses skia-pathops to merge bezier paths. The properties of merged patch will inherid from the bbox patch.\n\nfrom mpl_speech_bubble import annotate_merged\n\nxy = (0.5, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nt = annotate_merged(\n    ax,\n    text=\"Merged\",\n    xy=xy, xycoords='data',\n    xytext=(-0., .9), textcoords=\"offset fontsize\",\n    **annotate_kwargs\n)\n\n\n\n\nIn addtion, it provides annotate-bubble function. It has slghtly different call signature from annotate, but has an advantage of better handling of things like rotation.\nInstead of xytext and textcoords, you should use loc and dist. The unit of dist is fontsize.\n\nfrom mpl_speech_bubble import annotate_bubble\n\nxy = (0.8, 0.5)\nax.plot([xy[0]], [xy[1]], \"o\")\n\nt = annotate_bubble(\n    ax,\n    text=\"Bubble\",\n    xy=xy, xycoords='data',\n    loc=\"up\", dist=1.,\n    size=20,\n)\n\n\n\n\n\n\n\nt = annotate_bubble(\n    ax,\n    text=\"Bubble 2\",\n    xy=xy, xycoords='data',\n    loc=\"down\", dist=1.,\n    size=20, rotation=30,\n)\n\n\n\n\n\n\nannotate_bubble is a simple wrapper around AnnotationBubble class. Please take a look at the example here"
  },
  {
    "objectID": "posts/mpl-20240318-mpl-flags/index.html",
    "href": "posts/mpl-20240318-mpl-flags/index.html",
    "title": "mpl-flags : drawing flags with Matplotlib",
    "section": "",
    "text": "This post is to introduce mpl-flags package. To demonstrate the package, we would like to reproduce the plot from this post, only the barchart part.\nWe will start the demo by loading the data as pandas DataFrame.\n\nimport pandas as pd\nimport io\n\ncsvs = \"\"\"Country,2024 Real GDP % Change,Code\nIndia,6.5,IN\nIndonesia,5,ID\nChina,4.6,CN\nTürkiye,3,TR\nArgentina,2.8,AR\nMexico,2.7,MX\nSaudi Arabia,2.7,SA\nRussia,2.6,RU\nKorea,2.2,KR\nU.S.,2.1,US\nBrazil,1.7,BR\nCanada,1.4,CA\nAustralia,1.2,AU\nFrance,1,FR\nSouth Africa,1,ZA\nJapan,0.9,JP\nItaly,0.7,IT\nUnited Kingdom,0.6,GB\nGermany,0.5,DE\n\"\"\"\n\ndf = pd.read_csv(io.StringIO(csvs))\n\n\n\nWe will first show the full example source, then we will introduce mpl-flags and explain how it works.\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.offsetbox import (TextArea, DrawingArea, AnnotationBbox, VPacker)\nfrom matplotlib.patches import Circle\nfrom mpl_flags import Flags\n\nfig, ax = plt.subplots(1, 1, num=1, figsize=(7, 10), clear=True,\n                       facecolor=\"gold\")\ncountries = df[\"Country\"]\ngdp_changes = df[\"2024 Real GDP % Change\"]\ncountry_codes = df[\"Code\"]\n\npalette = sns.color_palette(\"crest\", n_colors=len(countries))\npalette.reverse()\n\nsns.barplot(x=gdp_changes, y=countries,\n            hue=countries,\n            palette=palette,\n            width=0.9,\n            ax=ax)\n\n\nfor country, gdp_change, bar in zip(countries, gdp_changes, ax.patches):\n    t1 = TextArea(country, textprops=dict(size=10))\n    t2 = TextArea(f\"{gdp_change}%\", textprops=dict(size=14))\n    tt = VPacker(align=\"left\", children=[t1, t2], sep=2)\n    ab = AnnotationBbox(tt, (1, 0.5), xybox=(5, 0),\n                        frameon=False,\n                        xycoords=bar,\n                        boxcoords=\"offset points\",\n                        box_alignment=(0., 0.5))\n    ax.add_artist(ab)\n\nflags = Flags(\"circle\")\n\nkw = dict(frameon=False,\n          box_alignment=(0.5, 0.5))\n\nfor country, code, bar in zip(countries, country_codes, ax.patches):\n\n    # draw white circular background around the flags\n    da = DrawingArea(20, 20, clip=False)\n    da.add_artist(Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\n    da = flags.get_drawing_area(code, wmax=25)\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\nfrom matplotlib.patches import FancyArrowPatch\n\n\nda = DrawingArea(70, 10, clip=False)\narrow = FancyArrowPatch(posA=(0, 5), posB=(70, 5),\n                        arrowstyle='fancy,tail_width=0.2', connectionstyle='arc3',\n                        mutation_scale=15, ec=\"none\", fc=\"w\")\nda.add_artist(arrow) # Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\nt1 = TextArea(\"2024 Real GDP % Change\", textprops=dict(size=12, color=\"w\"))\ntt = VPacker(align=\"right\", children=[t1, da], sep=2)\n\nab = AnnotationBbox(tt, (0.98, 0.5), xycoords=ax.patches[0],\n                    frameon=False,\n                    box_alignment=(1, 0.5))\nax.add_artist(ab)\n\nfig.subplots_adjust(top=0.95, bottom=0.05)\nfig.set_facecolor(\"gold\")\nax.set_axis_off()\n\nplt.show()"
  },
  {
    "objectID": "posts/mpl-20240318-mpl-flags/index.html#full-example",
    "href": "posts/mpl-20240318-mpl-flags/index.html#full-example",
    "title": "mpl-flags : drawing flags with Matplotlib",
    "section": "",
    "text": "We will first show the full example source, then we will introduce mpl-flags and explain how it works.\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.offsetbox import (TextArea, DrawingArea, AnnotationBbox, VPacker)\nfrom matplotlib.patches import Circle\nfrom mpl_flags import Flags\n\nfig, ax = plt.subplots(1, 1, num=1, figsize=(7, 10), clear=True,\n                       facecolor=\"gold\")\ncountries = df[\"Country\"]\ngdp_changes = df[\"2024 Real GDP % Change\"]\ncountry_codes = df[\"Code\"]\n\npalette = sns.color_palette(\"crest\", n_colors=len(countries))\npalette.reverse()\n\nsns.barplot(x=gdp_changes, y=countries,\n            hue=countries,\n            palette=palette,\n            width=0.9,\n            ax=ax)\n\n\nfor country, gdp_change, bar in zip(countries, gdp_changes, ax.patches):\n    t1 = TextArea(country, textprops=dict(size=10))\n    t2 = TextArea(f\"{gdp_change}%\", textprops=dict(size=14))\n    tt = VPacker(align=\"left\", children=[t1, t2], sep=2)\n    ab = AnnotationBbox(tt, (1, 0.5), xybox=(5, 0),\n                        frameon=False,\n                        xycoords=bar,\n                        boxcoords=\"offset points\",\n                        box_alignment=(0., 0.5))\n    ax.add_artist(ab)\n\nflags = Flags(\"circle\")\n\nkw = dict(frameon=False,\n          box_alignment=(0.5, 0.5))\n\nfor country, code, bar in zip(countries, country_codes, ax.patches):\n\n    # draw white circular background around the flags\n    da = DrawingArea(20, 20, clip=False)\n    da.add_artist(Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\n    da = flags.get_drawing_area(code, wmax=25)\n    ab = AnnotationBbox(da, (0, 0.5), xycoords=bar, **kw)\n    ax.add_artist(ab)\n\nfrom matplotlib.patches import FancyArrowPatch\n\n\nda = DrawingArea(70, 10, clip=False)\narrow = FancyArrowPatch(posA=(0, 5), posB=(70, 5),\n                        arrowstyle='fancy,tail_width=0.2', connectionstyle='arc3',\n                        mutation_scale=15, ec=\"none\", fc=\"w\")\nda.add_artist(arrow) # Circle((10, 10), 15, ec=\"none\", fc=\"w\"))\nt1 = TextArea(\"2024 Real GDP % Change\", textprops=dict(size=12, color=\"w\"))\ntt = VPacker(align=\"right\", children=[t1, da], sep=2)\n\nab = AnnotationBbox(tt, (0.98, 0.5), xycoords=ax.patches[0],\n                    frameon=False,\n                    box_alignment=(1, 0.5))\nax.add_artist(ab)\n\nfig.subplots_adjust(top=0.95, bottom=0.05)\nfig.set_facecolor(\"gold\")\nax.set_axis_off()\n\nplt.show()"
  }
]